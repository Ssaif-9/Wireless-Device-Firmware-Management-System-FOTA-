
APP_2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  0800c800  0800c800  00000800  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000025d4  0800c90c  0800c90c  0000090c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000002c  0800eee0  0800eee0  00002ee0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800ef0c  0800ef0c  00003010  2**0
                  CONTENTS
  4 .ARM          00000000  0800ef0c  0800ef0c  00003010  2**0
                  CONTENTS
  5 .preinit_array 00000000  0800ef0c  0800ef0c  00003010  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800ef0c  0800ef0c  00002f0c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800ef10  0800ef10  00002f10  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000010  20000000  0800ef14  00003000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000000bc  20000010  0800ef24  00003010  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  200000cc  0800ef24  000030cc  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00003010  2**0
                  CONTENTS, READONLY
 12 .debug_info   00008a79  00000000  00000000  00003039  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 000018cc  00000000  00000000  0000bab2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 000007e0  00000000  00000000  0000d380  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 000005fb  00000000  00000000  0000db60  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0001668c  00000000  00000000  0000e15b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00009234  00000000  00000000  000247e7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00081067  00000000  00000000  0002da1b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  000aea82  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00001ec4  00000000  00000000  000aeac8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 0000004a  00000000  00000000  000b098c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0800c90c <__do_global_dtors_aux>:
 800c90c:	b510      	push	{r4, lr}
 800c90e:	4c05      	ldr	r4, [pc, #20]	@ (800c924 <__do_global_dtors_aux+0x18>)
 800c910:	7823      	ldrb	r3, [r4, #0]
 800c912:	b933      	cbnz	r3, 800c922 <__do_global_dtors_aux+0x16>
 800c914:	4b04      	ldr	r3, [pc, #16]	@ (800c928 <__do_global_dtors_aux+0x1c>)
 800c916:	b113      	cbz	r3, 800c91e <__do_global_dtors_aux+0x12>
 800c918:	4804      	ldr	r0, [pc, #16]	@ (800c92c <__do_global_dtors_aux+0x20>)
 800c91a:	f3af 8000 	nop.w
 800c91e:	2301      	movs	r3, #1
 800c920:	7023      	strb	r3, [r4, #0]
 800c922:	bd10      	pop	{r4, pc}
 800c924:	20000010 	.word	0x20000010
 800c928:	00000000 	.word	0x00000000
 800c92c:	0800eec8 	.word	0x0800eec8

0800c930 <frame_dummy>:
 800c930:	b508      	push	{r3, lr}
 800c932:	4b03      	ldr	r3, [pc, #12]	@ (800c940 <frame_dummy+0x10>)
 800c934:	b11b      	cbz	r3, 800c93e <frame_dummy+0xe>
 800c936:	4903      	ldr	r1, [pc, #12]	@ (800c944 <frame_dummy+0x14>)
 800c938:	4803      	ldr	r0, [pc, #12]	@ (800c948 <frame_dummy+0x18>)
 800c93a:	f3af 8000 	nop.w
 800c93e:	bd08      	pop	{r3, pc}
 800c940:	00000000 	.word	0x00000000
 800c944:	20000014 	.word	0x20000014
 800c948:	0800eec8 	.word	0x0800eec8

0800c94c <FPEC_voidFlashPageErase>:
		FPEC_voidFlashPageErase(Local_u8Counter);
}

//Erase Flash Page
u8 FPEC_voidFlashPageErase(u8 Copy_u8PageNumber)
{
 800c94c:	b480      	push	{r7}
 800c94e:	b085      	sub	sp, #20
 800c950:	af00      	add	r7, sp, #0
 800c952:	4603      	mov	r3, r0
 800c954:	71fb      	strb	r3, [r7, #7]
	u8 Local_u8ErrorState = OK;
 800c956:	2300      	movs	r3, #0
 800c958:	73fb      	strb	r3, [r7, #15]

	if (Copy_u8PageNumber<=FPEC_MAX_NUM_PAGE)
 800c95a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800c95e:	2b00      	cmp	r3, #0
 800c960:	db2c      	blt.n	800c9bc <FPEC_voidFlashPageErase+0x70>
	{
		while (GET_BIT(FPEC->FLASH_SR ,0)==1);
 800c962:	bf00      	nop
 800c964:	4b19      	ldr	r3, [pc, #100]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c966:	68db      	ldr	r3, [r3, #12]
 800c968:	f003 0301 	and.w	r3, r3, #1
 800c96c:	2b01      	cmp	r3, #1
 800c96e:	d0f9      	beq.n	800c964 <FPEC_voidFlashPageErase+0x18>

		SET_BIT(FPEC->FLASH_CR,1);
 800c970:	4b16      	ldr	r3, [pc, #88]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c972:	691b      	ldr	r3, [r3, #16]
 800c974:	4a15      	ldr	r2, [pc, #84]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c976:	f043 0302 	orr.w	r3, r3, #2
 800c97a:	6113      	str	r3, [r2, #16]

		FPEC->FLASH_AR = (u32)(Copy_u8PageNumber*1024)+0x08000000 ;
 800c97c:	79fb      	ldrb	r3, [r7, #7]
 800c97e:	029b      	lsls	r3, r3, #10
 800c980:	4a12      	ldr	r2, [pc, #72]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c982:	f103 6300 	add.w	r3, r3, #134217728	@ 0x8000000
 800c986:	6153      	str	r3, [r2, #20]
		//Start operation erase
		SET_BIT(FPEC->FLASH_CR ,6) ;
 800c988:	4b10      	ldr	r3, [pc, #64]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c98a:	691b      	ldr	r3, [r3, #16]
 800c98c:	4a0f      	ldr	r2, [pc, #60]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c98e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800c992:	6113      	str	r3, [r2, #16]

		while (GET_BIT(FPEC->FLASH_SR ,0)==1);
 800c994:	bf00      	nop
 800c996:	4b0d      	ldr	r3, [pc, #52]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c998:	68db      	ldr	r3, [r3, #12]
 800c99a:	f003 0301 	and.w	r3, r3, #1
 800c99e:	2b01      	cmp	r3, #1
 800c9a0:	d0f9      	beq.n	800c996 <FPEC_voidFlashPageErase+0x4a>

		//END OPERATION
		SET_BIT(FPEC->FLASH_SR ,5);
 800c9a2:	4b0a      	ldr	r3, [pc, #40]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c9a4:	68db      	ldr	r3, [r3, #12]
 800c9a6:	4a09      	ldr	r2, [pc, #36]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c9a8:	f043 0320 	orr.w	r3, r3, #32
 800c9ac:	60d3      	str	r3, [r2, #12]
		CLR_BIT(FPEC->FLASH_CR,1);
 800c9ae:	4b07      	ldr	r3, [pc, #28]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c9b0:	691b      	ldr	r3, [r3, #16]
 800c9b2:	4a06      	ldr	r2, [pc, #24]	@ (800c9cc <FPEC_voidFlashPageErase+0x80>)
 800c9b4:	f023 0302 	bic.w	r3, r3, #2
 800c9b8:	6113      	str	r3, [r2, #16]
 800c9ba:	e001      	b.n	800c9c0 <FPEC_voidFlashPageErase+0x74>
	}
	else
		Local_u8ErrorState = NOK;
 800c9bc:	2301      	movs	r3, #1
 800c9be:	73fb      	strb	r3, [r7, #15]
	
	return Local_u8ErrorState;
 800c9c0:	7bfb      	ldrb	r3, [r7, #15]
}
 800c9c2:	4618      	mov	r0, r3
 800c9c4:	3714      	adds	r7, #20
 800c9c6:	46bd      	mov	sp, r7
 800c9c8:	bc80      	pop	{r7}
 800c9ca:	4770      	bx	lr
 800c9cc:	40022000 	.word	0x40022000

0800c9d0 <FPEC_voidFlashWrite>:

//Write to flash
void FPEC_voidFlashWrite(u32 Copy_u32Address, u16* Copy_u16Data, u8 Copy_u8Length)
{
 800c9d0:	b480      	push	{r7}
 800c9d2:	b087      	sub	sp, #28
 800c9d4:	af00      	add	r7, sp, #0
 800c9d6:	60f8      	str	r0, [r7, #12]
 800c9d8:	60b9      	str	r1, [r7, #8]
 800c9da:	4613      	mov	r3, r2
 800c9dc:	71fb      	strb	r3, [r7, #7]
	for (u8 Local_u8Counter = 0 ; Local_u8Counter<Copy_u8Length ; Local_u8Counter++)
 800c9de:	2300      	movs	r3, #0
 800c9e0:	75fb      	strb	r3, [r7, #23]
 800c9e2:	e025      	b.n	800ca30 <FPEC_voidFlashWrite+0x60>
	{

		SET_BIT(FPEC->FLASH_CR,0);
 800c9e4:	4b17      	ldr	r3, [pc, #92]	@ (800ca44 <FPEC_voidFlashWrite+0x74>)
 800c9e6:	691b      	ldr	r3, [r3, #16]
 800c9e8:	4a16      	ldr	r2, [pc, #88]	@ (800ca44 <FPEC_voidFlashWrite+0x74>)
 800c9ea:	f043 0301 	orr.w	r3, r3, #1
 800c9ee:	6113      	str	r3, [r2, #16]

		*((volatile u16 *)(Copy_u32Address)) =  Copy_u16Data[Local_u8Counter];
 800c9f0:	7dfb      	ldrb	r3, [r7, #23]
 800c9f2:	005b      	lsls	r3, r3, #1
 800c9f4:	68ba      	ldr	r2, [r7, #8]
 800c9f6:	441a      	add	r2, r3
 800c9f8:	68fb      	ldr	r3, [r7, #12]
 800c9fa:	8812      	ldrh	r2, [r2, #0]
 800c9fc:	801a      	strh	r2, [r3, #0]

		/*Waitting util the write operation is end*/

		while (GET_BIT(FPEC->FLASH_SR,0) == 1);
 800c9fe:	bf00      	nop
 800ca00:	4b10      	ldr	r3, [pc, #64]	@ (800ca44 <FPEC_voidFlashWrite+0x74>)
 800ca02:	68db      	ldr	r3, [r3, #12]
 800ca04:	f003 0301 	and.w	r3, r3, #1
 800ca08:	2b01      	cmp	r3, #1
 800ca0a:	d0f9      	beq.n	800ca00 <FPEC_voidFlashWrite+0x30>

		SET_BIT(FPEC->FLASH_SR,5);
 800ca0c:	4b0d      	ldr	r3, [pc, #52]	@ (800ca44 <FPEC_voidFlashWrite+0x74>)
 800ca0e:	68db      	ldr	r3, [r3, #12]
 800ca10:	4a0c      	ldr	r2, [pc, #48]	@ (800ca44 <FPEC_voidFlashWrite+0x74>)
 800ca12:	f043 0320 	orr.w	r3, r3, #32
 800ca16:	60d3      	str	r3, [r2, #12]
		CLR_BIT(FPEC->FLASH_CR,0);
 800ca18:	4b0a      	ldr	r3, [pc, #40]	@ (800ca44 <FPEC_voidFlashWrite+0x74>)
 800ca1a:	691b      	ldr	r3, [r3, #16]
 800ca1c:	4a09      	ldr	r2, [pc, #36]	@ (800ca44 <FPEC_voidFlashWrite+0x74>)
 800ca1e:	f023 0301 	bic.w	r3, r3, #1
 800ca22:	6113      	str	r3, [r2, #16]

		Copy_u32Address=Copy_u32Address+2;
 800ca24:	68fb      	ldr	r3, [r7, #12]
 800ca26:	3302      	adds	r3, #2
 800ca28:	60fb      	str	r3, [r7, #12]
	for (u8 Local_u8Counter = 0 ; Local_u8Counter<Copy_u8Length ; Local_u8Counter++)
 800ca2a:	7dfb      	ldrb	r3, [r7, #23]
 800ca2c:	3301      	adds	r3, #1
 800ca2e:	75fb      	strb	r3, [r7, #23]
 800ca30:	7dfa      	ldrb	r2, [r7, #23]
 800ca32:	79fb      	ldrb	r3, [r7, #7]
 800ca34:	429a      	cmp	r2, r3
 800ca36:	d3d5      	bcc.n	800c9e4 <FPEC_voidFlashWrite+0x14>

	}
}
 800ca38:	bf00      	nop
 800ca3a:	bf00      	nop
 800ca3c:	371c      	adds	r7, #28
 800ca3e:	46bd      	mov	sp, r7
 800ca40:	bc80      	pop	{r7}
 800ca42:	4770      	bx	lr
 800ca44:	40022000 	.word	0x40022000

0800ca48 <forward>:
#include "DC_interface.h"
#include "DC_config.h"
#include "DC_private.h"
#include "main.h"
//*********functions for driver l293d****************//
void forward(){
 800ca48:	b580      	push	{r7, lr}
 800ca4a:	af00      	add	r7, sp, #0
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);
 800ca4c:	2201      	movs	r2, #1
 800ca4e:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 800ca52:	480b      	ldr	r0, [pc, #44]	@ (800ca80 <forward+0x38>)
 800ca54:	f001 fbec 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,GPIO_PIN_RESET);
 800ca58:	2200      	movs	r2, #0
 800ca5a:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800ca5e:	4808      	ldr	r0, [pc, #32]	@ (800ca80 <forward+0x38>)
 800ca60:	f001 fbe6 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14,GPIO_PIN_RESET);
 800ca64:	2200      	movs	r2, #0
 800ca66:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 800ca6a:	4805      	ldr	r0, [pc, #20]	@ (800ca80 <forward+0x38>)
 800ca6c:	f001 fbe0 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15,GPIO_PIN_SET);
 800ca70:	2201      	movs	r2, #1
 800ca72:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 800ca76:	4802      	ldr	r0, [pc, #8]	@ (800ca80 <forward+0x38>)
 800ca78:	f001 fbda 	bl	800e230 <HAL_GPIO_WritePin>

}
 800ca7c:	bf00      	nop
 800ca7e:	bd80      	pop	{r7, pc}
 800ca80:	40010c00 	.word	0x40010c00

0800ca84 <backward>:
void backward(){
 800ca84:	b580      	push	{r7, lr}
 800ca86:	af00      	add	r7, sp, #0
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,GPIO_PIN_RESET);
 800ca88:	2200      	movs	r2, #0
 800ca8a:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 800ca8e:	480b      	ldr	r0, [pc, #44]	@ (800cabc <backward+0x38>)
 800ca90:	f001 fbce 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,GPIO_PIN_SET);
 800ca94:	2201      	movs	r2, #1
 800ca96:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800ca9a:	4808      	ldr	r0, [pc, #32]	@ (800cabc <backward+0x38>)
 800ca9c:	f001 fbc8 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14,GPIO_PIN_SET);
 800caa0:	2201      	movs	r2, #1
 800caa2:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 800caa6:	4805      	ldr	r0, [pc, #20]	@ (800cabc <backward+0x38>)
 800caa8:	f001 fbc2 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15,GPIO_PIN_RESET);
 800caac:	2200      	movs	r2, #0
 800caae:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 800cab2:	4802      	ldr	r0, [pc, #8]	@ (800cabc <backward+0x38>)
 800cab4:	f001 fbbc 	bl	800e230 <HAL_GPIO_WritePin>

}
 800cab8:	bf00      	nop
 800caba:	bd80      	pop	{r7, pc}
 800cabc:	40010c00 	.word	0x40010c00

0800cac0 <left>:
void left(){
 800cac0:	b580      	push	{r7, lr}
 800cac2:	af00      	add	r7, sp, #0
	//DC_vidStart(GPIOB, PIN5,95);
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,GPIO_PIN_SET);
 800cac4:	2201      	movs	r2, #1
 800cac6:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 800caca:	480b      	ldr	r0, [pc, #44]	@ (800caf8 <left+0x38>)
 800cacc:	f001 fbb0 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,GPIO_PIN_RESET);
 800cad0:	2200      	movs	r2, #0
 800cad2:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800cad6:	4808      	ldr	r0, [pc, #32]	@ (800caf8 <left+0x38>)
 800cad8:	f001 fbaa 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14,GPIO_PIN_SET);
 800cadc:	2201      	movs	r2, #1
 800cade:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 800cae2:	4805      	ldr	r0, [pc, #20]	@ (800caf8 <left+0x38>)
 800cae4:	f001 fba4 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15,GPIO_PIN_RESET);
 800cae8:	2200      	movs	r2, #0
 800caea:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 800caee:	4802      	ldr	r0, [pc, #8]	@ (800caf8 <left+0x38>)
 800caf0:	f001 fb9e 	bl	800e230 <HAL_GPIO_WritePin>

}
 800caf4:	bf00      	nop
 800caf6:	bd80      	pop	{r7, pc}
 800caf8:	40010c00 	.word	0x40010c00

0800cafc <right>:
void right(){
 800cafc:	b580      	push	{r7, lr}
 800cafe:	af00      	add	r7, sp, #0
	//DC_vidStart(GPIOB, PIN5, 95);
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,GPIO_PIN_RESET);
 800cb00:	2200      	movs	r2, #0
 800cb02:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 800cb06:	480b      	ldr	r0, [pc, #44]	@ (800cb34 <right+0x38>)
 800cb08:	f001 fb92 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,GPIO_PIN_SET);
 800cb0c:	2201      	movs	r2, #1
 800cb0e:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800cb12:	4808      	ldr	r0, [pc, #32]	@ (800cb34 <right+0x38>)
 800cb14:	f001 fb8c 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14,GPIO_PIN_RESET);
 800cb18:	2200      	movs	r2, #0
 800cb1a:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 800cb1e:	4805      	ldr	r0, [pc, #20]	@ (800cb34 <right+0x38>)
 800cb20:	f001 fb86 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15,GPIO_PIN_SET);
 800cb24:	2201      	movs	r2, #1
 800cb26:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 800cb2a:	4802      	ldr	r0, [pc, #8]	@ (800cb34 <right+0x38>)
 800cb2c:	f001 fb80 	bl	800e230 <HAL_GPIO_WritePin>


}
 800cb30:	bf00      	nop
 800cb32:	bd80      	pop	{r7, pc}
 800cb34:	40010c00 	.word	0x40010c00

0800cb38 <stop>:
void stop(){
 800cb38:	b580      	push	{r7, lr}
 800cb3a:	af00      	add	r7, sp, #0

	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,GPIO_PIN_RESET);
 800cb3c:	2200      	movs	r2, #0
 800cb3e:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 800cb42:	480b      	ldr	r0, [pc, #44]	@ (800cb70 <stop+0x38>)
 800cb44:	f001 fb74 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,GPIO_PIN_RESET);
 800cb48:	2200      	movs	r2, #0
 800cb4a:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800cb4e:	4808      	ldr	r0, [pc, #32]	@ (800cb70 <stop+0x38>)
 800cb50:	f001 fb6e 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14,GPIO_PIN_RESET);
 800cb54:	2200      	movs	r2, #0
 800cb56:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 800cb5a:	4805      	ldr	r0, [pc, #20]	@ (800cb70 <stop+0x38>)
 800cb5c:	f001 fb68 	bl	800e230 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15,GPIO_PIN_RESET);
 800cb60:	2200      	movs	r2, #0
 800cb62:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 800cb66:	4802      	ldr	r0, [pc, #8]	@ (800cb70 <stop+0x38>)
 800cb68:	f001 fb62 	bl	800e230 <HAL_GPIO_WritePin>

}
 800cb6c:	bf00      	nop
 800cb6e:	bd80      	pop	{r7, pc}
 800cb70:	40010c00 	.word	0x40010c00

0800cb74 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
 800cb74:	b480      	push	{r7}
 800cb76:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800cb78:	f3bf 8f4f 	dsb	sy
}
 800cb7c:	bf00      	nop
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800cb7e:	4b06      	ldr	r3, [pc, #24]	@ (800cb98 <__NVIC_SystemReset+0x24>)
 800cb80:	68db      	ldr	r3, [r3, #12]
 800cb82:	f403 62e0 	and.w	r2, r3, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800cb86:	4904      	ldr	r1, [pc, #16]	@ (800cb98 <__NVIC_SystemReset+0x24>)
 800cb88:	4b04      	ldr	r3, [pc, #16]	@ (800cb9c <__NVIC_SystemReset+0x28>)
 800cb8a:	4313      	orrs	r3, r2
 800cb8c:	60cb      	str	r3, [r1, #12]
  __ASM volatile ("dsb 0xF":::"memory");
 800cb8e:	f3bf 8f4f 	dsb	sy
}
 800cb92:	bf00      	nop
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800cb94:	bf00      	nop
 800cb96:	e7fd      	b.n	800cb94 <__NVIC_SystemReset+0x20>
 800cb98:	e000ed00 	.word	0xe000ed00
 800cb9c:	05fa0004 	.word	0x05fa0004

0800cba0 <HAL_CAN_RxFifo0MsgPendingCallback>:

uint8_t               TxData[8];
uint8_t               RxData[8];

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
 800cba0:	b580      	push	{r7, lr}
 800cba2:	b084      	sub	sp, #16
 800cba4:	af00      	add	r7, sp, #0
 800cba6:	6078      	str	r0, [r7, #4]
	 HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData);
 800cba8:	4b0d      	ldr	r3, [pc, #52]	@ (800cbe0 <HAL_CAN_RxFifo0MsgPendingCallback+0x40>)
 800cbaa:	4a0e      	ldr	r2, [pc, #56]	@ (800cbe4 <HAL_CAN_RxFifo0MsgPendingCallback+0x44>)
 800cbac:	2100      	movs	r1, #0
 800cbae:	6878      	ldr	r0, [r7, #4]
 800cbb0:	f000 fd5c 	bl	800d66c <HAL_CAN_GetRxMessage>

	  uint16_t Local_u16Data=0;
 800cbb4:	2300      	movs	r3, #0
 800cbb6:	81fb      	strh	r3, [r7, #14]

	  	if(RxHeader.data[0]=='u')
 800cbb8:	4b0a      	ldr	r3, [pc, #40]	@ (800cbe4 <HAL_CAN_RxFifo0MsgPendingCallback+0x44>)
 800cbba:	7f1b      	ldrb	r3, [r3, #28]
 800cbbc:	2b75      	cmp	r3, #117	@ 0x75
 800cbbe:	d10b      	bne.n	800cbd8 <HAL_CAN_RxFifo0MsgPendingCallback+0x38>
	  	{


	  		FPEC_voidFlashPageErase(120);
 800cbc0:	2078      	movs	r0, #120	@ 0x78
 800cbc2:	f7ff fec3 	bl	800c94c <FPEC_voidFlashPageErase>
			FPEC_voidFlashWrite(BOOT_u8REQUESTFLAG,&Local_u16Data,1);
 800cbc6:	f107 030e 	add.w	r3, r7, #14
 800cbca:	2201      	movs	r2, #1
 800cbcc:	4619      	mov	r1, r3
 800cbce:	4806      	ldr	r0, [pc, #24]	@ (800cbe8 <HAL_CAN_RxFifo0MsgPendingCallback+0x48>)
 800cbd0:	f7ff fefe 	bl	800c9d0 <FPEC_voidFlashWrite>
			NVIC_SystemReset();
 800cbd4:	f7ff ffce 	bl	800cb74 <__NVIC_SystemReset>

	  	}

}
 800cbd8:	bf00      	nop
 800cbda:	3710      	adds	r7, #16
 800cbdc:	46bd      	mov	sp, r7
 800cbde:	bd80      	pop	{r7, pc}
 800cbe0:	200000c0 	.word	0x200000c0
 800cbe4:	2000009c 	.word	0x2000009c
 800cbe8:	0801e000 	.word	0x0801e000

0800cbec <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800cbec:	b580      	push	{r7, lr}
 800cbee:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800cbf0:	f000 fad2 	bl	800d198 <HAL_Init>


  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800cbf4:	f000 f86e 	bl	800ccd4 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800cbf8:	f000 f930 	bl	800ce5c <MX_GPIO_Init>
  MX_USART1_UART_Init();
 800cbfc:	f000 f904 	bl	800ce08 <MX_USART1_UART_Init>
  MX_CAN_Init();
 800cc00:	f000 f8ae 	bl	800cd60 <MX_CAN_Init>
  /* USER CODE BEGIN 2 */

  HAL_CAN_Start(&hcan);
 800cc04:	482e      	ldr	r0, [pc, #184]	@ (800ccc0 <main+0xd4>)
 800cc06:	f000 fced 	bl	800d5e4 <HAL_CAN_Start>
  HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);
 800cc0a:	2102      	movs	r1, #2
 800cc0c:	482c      	ldr	r0, [pc, #176]	@ (800ccc0 <main+0xd4>)
 800cc0e:	f000 fe35 	bl	800d87c <HAL_CAN_ActivateNotification>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  HAL_UART_Receive(&huart1, &rx, 1, HAL_MAX_DELAY);
 800cc12:	f04f 33ff 	mov.w	r3, #4294967295
 800cc16:	2201      	movs	r2, #1
 800cc18:	492a      	ldr	r1, [pc, #168]	@ (800ccc4 <main+0xd8>)
 800cc1a:	482b      	ldr	r0, [pc, #172]	@ (800ccc8 <main+0xdc>)
 800cc1c:	f001 ff9a 	bl	800eb54 <HAL_UART_Receive>
	 // LCD_enuGoTo(0,0);
	 // LCD_enuSendCharacter('c');
	 // LCD_enuSendCharacter(rx);


	  switch(rx)
 800cc20:	4b28      	ldr	r3, [pc, #160]	@ (800ccc4 <main+0xd8>)
 800cc22:	781b      	ldrb	r3, [r3, #0]
 800cc24:	3b42      	subs	r3, #66	@ 0x42
 800cc26:	2b11      	cmp	r3, #17
 800cc28:	d844      	bhi.n	800ccb4 <main+0xc8>
 800cc2a:	a201      	add	r2, pc, #4	@ (adr r2, 800cc30 <main+0x44>)
 800cc2c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800cc30:	0800cc85 	.word	0x0800cc85
 800cc34:	0800ccb5 	.word	0x0800ccb5
 800cc38:	0800ccb5 	.word	0x0800ccb5
 800cc3c:	0800ccb5 	.word	0x0800ccb5
 800cc40:	0800cc79 	.word	0x0800cc79
 800cc44:	0800ccb5 	.word	0x0800ccb5
 800cc48:	0800ccb5 	.word	0x0800ccb5
 800cc4c:	0800ccb5 	.word	0x0800ccb5
 800cc50:	0800ccb5 	.word	0x0800ccb5
 800cc54:	0800ccb5 	.word	0x0800ccb5
 800cc58:	0800cc91 	.word	0x0800cc91
 800cc5c:	0800ccb5 	.word	0x0800ccb5
 800cc60:	0800ccb5 	.word	0x0800ccb5
 800cc64:	0800ccb5 	.word	0x0800ccb5
 800cc68:	0800ccb5 	.word	0x0800ccb5
 800cc6c:	0800ccb5 	.word	0x0800ccb5
 800cc70:	0800cc9d 	.word	0x0800cc9d
 800cc74:	0800cca9 	.word	0x0800cca9
	  {
	  	 case 'F': backward();  Mode=Critical_Mode;  break;
 800cc78:	f7ff ff04 	bl	800ca84 <backward>
 800cc7c:	4b13      	ldr	r3, [pc, #76]	@ (800cccc <main+0xe0>)
 800cc7e:	2243      	movs	r2, #67	@ 0x43
 800cc80:	701a      	strb	r2, [r3, #0]
 800cc82:	e017      	b.n	800ccb4 <main+0xc8>
	  	 case 'B': forward(); Mode=Critical_Mode;break;
 800cc84:	f7ff fee0 	bl	800ca48 <forward>
 800cc88:	4b10      	ldr	r3, [pc, #64]	@ (800cccc <main+0xe0>)
 800cc8a:	2243      	movs	r2, #67	@ 0x43
 800cc8c:	701a      	strb	r2, [r3, #0]
 800cc8e:	e011      	b.n	800ccb4 <main+0xc8>
	  	 case 'L': right();     Mode=Critical_Mode; break;
 800cc90:	f7ff ff34 	bl	800cafc <right>
 800cc94:	4b0d      	ldr	r3, [pc, #52]	@ (800cccc <main+0xe0>)
 800cc96:	2243      	movs	r2, #67	@ 0x43
 800cc98:	701a      	strb	r2, [r3, #0]
 800cc9a:	e00b      	b.n	800ccb4 <main+0xc8>
	  	 case 'R': left();    Mode=Critical_Mode;   break;
 800cc9c:	f7ff ff10 	bl	800cac0 <left>
 800cca0:	4b0a      	ldr	r3, [pc, #40]	@ (800cccc <main+0xe0>)
 800cca2:	2243      	movs	r2, #67	@ 0x43
 800cca4:	701a      	strb	r2, [r3, #0]
 800cca6:	e005      	b.n	800ccb4 <main+0xc8>
	     case 'S': stop();     Mode=Safe_Mode;   break;
 800cca8:	f7ff ff46 	bl	800cb38 <stop>
 800ccac:	4b07      	ldr	r3, [pc, #28]	@ (800cccc <main+0xe0>)
 800ccae:	2253      	movs	r2, #83	@ 0x53
 800ccb0:	701a      	strb	r2, [r3, #0]
 800ccb2:	bf00      	nop

	  }



	  HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_10);
 800ccb4:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 800ccb8:	4805      	ldr	r0, [pc, #20]	@ (800ccd0 <main+0xe4>)
 800ccba:	f001 fad1 	bl	800e260 <HAL_GPIO_TogglePin>
	  HAL_UART_Receive(&huart1, &rx, 1, HAL_MAX_DELAY);
 800ccbe:	e7a8      	b.n	800cc12 <main+0x26>
 800ccc0:	2000002c 	.word	0x2000002c
 800ccc4:	20000000 	.word	0x20000000
 800ccc8:	20000054 	.word	0x20000054
 800cccc:	20000001 	.word	0x20000001
 800ccd0:	40010c00 	.word	0x40010c00

0800ccd4 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800ccd4:	b580      	push	{r7, lr}
 800ccd6:	b090      	sub	sp, #64	@ 0x40
 800ccd8:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800ccda:	f107 0318 	add.w	r3, r7, #24
 800ccde:	2228      	movs	r2, #40	@ 0x28
 800cce0:	2100      	movs	r1, #0
 800cce2:	4618      	mov	r0, r3
 800cce4:	f002 f8c4 	bl	800ee70 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800cce8:	1d3b      	adds	r3, r7, #4
 800ccea:	2200      	movs	r2, #0
 800ccec:	601a      	str	r2, [r3, #0]
 800ccee:	605a      	str	r2, [r3, #4]
 800ccf0:	609a      	str	r2, [r3, #8]
 800ccf2:	60da      	str	r2, [r3, #12]
 800ccf4:	611a      	str	r2, [r3, #16]

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800ccf6:	2301      	movs	r3, #1
 800ccf8:	61bb      	str	r3, [r7, #24]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800ccfa:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 800ccfe:	61fb      	str	r3, [r7, #28]
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
 800cd00:	2300      	movs	r3, #0
 800cd02:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800cd04:	2301      	movs	r3, #1
 800cd06:	62bb      	str	r3, [r7, #40]	@ 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800cd08:	2302      	movs	r3, #2
 800cd0a:	637b      	str	r3, [r7, #52]	@ 0x34
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800cd0c:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 800cd10:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 800cd12:	f44f 13e0 	mov.w	r3, #1835008	@ 0x1c0000
 800cd16:	63fb      	str	r3, [r7, #60]	@ 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800cd18:	f107 0318 	add.w	r3, r7, #24
 800cd1c:	4618      	mov	r0, r3
 800cd1e:	f001 fab9 	bl	800e294 <HAL_RCC_OscConfig>
 800cd22:	4603      	mov	r3, r0
 800cd24:	2b00      	cmp	r3, #0
 800cd26:	d001      	beq.n	800cd2c <SystemClock_Config+0x58>
  {
    Error_Handler();
 800cd28:	f000 f8f8 	bl	800cf1c <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800cd2c:	230f      	movs	r3, #15
 800cd2e:	607b      	str	r3, [r7, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800cd30:	2302      	movs	r3, #2
 800cd32:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800cd34:	2300      	movs	r3, #0
 800cd36:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 800cd38:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800cd3c:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800cd3e:	2300      	movs	r3, #0
 800cd40:	617b      	str	r3, [r7, #20]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 800cd42:	1d3b      	adds	r3, r7, #4
 800cd44:	2102      	movs	r1, #2
 800cd46:	4618      	mov	r0, r3
 800cd48:	f001 fd26 	bl	800e798 <HAL_RCC_ClockConfig>
 800cd4c:	4603      	mov	r3, r0
 800cd4e:	2b00      	cmp	r3, #0
 800cd50:	d001      	beq.n	800cd56 <SystemClock_Config+0x82>
  {
    Error_Handler();
 800cd52:	f000 f8e3 	bl	800cf1c <Error_Handler>
  }
}
 800cd56:	bf00      	nop
 800cd58:	3740      	adds	r7, #64	@ 0x40
 800cd5a:	46bd      	mov	sp, r7
 800cd5c:	bd80      	pop	{r7, pc}
	...

0800cd60 <MX_CAN_Init>:
  * @brief CAN Initialization Function
  * @param None
  * @retval None
  */
static void MX_CAN_Init(void)
{
 800cd60:	b580      	push	{r7, lr}
 800cd62:	b08a      	sub	sp, #40	@ 0x28
 800cd64:	af00      	add	r7, sp, #0
  /* USER CODE END CAN_Init 0 */

  /* USER CODE BEGIN CAN_Init 1 */

  /* USER CODE END CAN_Init 1 */
  hcan.Instance = CAN1;
 800cd66:	4b26      	ldr	r3, [pc, #152]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cd68:	4a26      	ldr	r2, [pc, #152]	@ (800ce04 <MX_CAN_Init+0xa4>)
 800cd6a:	601a      	str	r2, [r3, #0]
  hcan.Init.Prescaler = 18;
 800cd6c:	4b24      	ldr	r3, [pc, #144]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cd6e:	2212      	movs	r2, #18
 800cd70:	605a      	str	r2, [r3, #4]
  hcan.Init.Mode = CAN_MODE_NORMAL;
 800cd72:	4b23      	ldr	r3, [pc, #140]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cd74:	2200      	movs	r2, #0
 800cd76:	609a      	str	r2, [r3, #8]
  hcan.Init.SyncJumpWidth = CAN_SJW_1TQ;
 800cd78:	4b21      	ldr	r3, [pc, #132]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cd7a:	2200      	movs	r2, #0
 800cd7c:	60da      	str	r2, [r3, #12]
  hcan.Init.TimeSeg1 = CAN_BS1_2TQ;
 800cd7e:	4b20      	ldr	r3, [pc, #128]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cd80:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800cd84:	611a      	str	r2, [r3, #16]
  hcan.Init.TimeSeg2 = CAN_BS2_1TQ;
 800cd86:	4b1e      	ldr	r3, [pc, #120]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cd88:	2200      	movs	r2, #0
 800cd8a:	615a      	str	r2, [r3, #20]
  hcan.Init.TimeTriggeredMode = DISABLE;
 800cd8c:	4b1c      	ldr	r3, [pc, #112]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cd8e:	2200      	movs	r2, #0
 800cd90:	761a      	strb	r2, [r3, #24]
  hcan.Init.AutoBusOff = DISABLE;
 800cd92:	4b1b      	ldr	r3, [pc, #108]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cd94:	2200      	movs	r2, #0
 800cd96:	765a      	strb	r2, [r3, #25]
  hcan.Init.AutoWakeUp = DISABLE;
 800cd98:	4b19      	ldr	r3, [pc, #100]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cd9a:	2200      	movs	r2, #0
 800cd9c:	769a      	strb	r2, [r3, #26]
  hcan.Init.AutoRetransmission = DISABLE;
 800cd9e:	4b18      	ldr	r3, [pc, #96]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cda0:	2200      	movs	r2, #0
 800cda2:	76da      	strb	r2, [r3, #27]
  hcan.Init.ReceiveFifoLocked = DISABLE;
 800cda4:	4b16      	ldr	r3, [pc, #88]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cda6:	2200      	movs	r2, #0
 800cda8:	771a      	strb	r2, [r3, #28]
  hcan.Init.TransmitFifoPriority = DISABLE;
 800cdaa:	4b15      	ldr	r3, [pc, #84]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cdac:	2200      	movs	r2, #0
 800cdae:	775a      	strb	r2, [r3, #29]
  if (HAL_CAN_Init(&hcan) != HAL_OK)
 800cdb0:	4813      	ldr	r0, [pc, #76]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cdb2:	f000 fa53 	bl	800d25c <HAL_CAN_Init>
 800cdb6:	4603      	mov	r3, r0
 800cdb8:	2b00      	cmp	r3, #0
 800cdba:	d001      	beq.n	800cdc0 <MX_CAN_Init+0x60>
  {
    Error_Handler();
 800cdbc:	f000 f8ae 	bl	800cf1c <Error_Handler>
  }
  /* USER CODE BEGIN CAN_Init 2 */
  CAN_FilterTypeDef canfilterconfig;

   canfilterconfig.FilterActivation = CAN_FILTER_ENABLE;
 800cdc0:	2301      	movs	r3, #1
 800cdc2:	623b      	str	r3, [r7, #32]
   canfilterconfig.FilterBank = 1;  // which filter bank to use from the assigned ones
 800cdc4:	2301      	movs	r3, #1
 800cdc6:	617b      	str	r3, [r7, #20]
   canfilterconfig.FilterFIFOAssignment = CAN_RX_FIFO0;
 800cdc8:	2300      	movs	r3, #0
 800cdca:	613b      	str	r3, [r7, #16]
   canfilterconfig.FilterIdHigh = 0x38<<5;
 800cdcc:	f44f 63e0 	mov.w	r3, #1792	@ 0x700
 800cdd0:	603b      	str	r3, [r7, #0]
   canfilterconfig.FilterIdLow = 0x0000;
 800cdd2:	2300      	movs	r3, #0
 800cdd4:	607b      	str	r3, [r7, #4]
   canfilterconfig.FilterMaskIdHigh = 0x38<<5;
 800cdd6:	f44f 63e0 	mov.w	r3, #1792	@ 0x700
 800cdda:	60bb      	str	r3, [r7, #8]
   canfilterconfig.FilterMaskIdLow = 0x0000;
 800cddc:	2300      	movs	r3, #0
 800cdde:	60fb      	str	r3, [r7, #12]
   canfilterconfig.FilterMode = CAN_FILTERMODE_IDMASK;
 800cde0:	2300      	movs	r3, #0
 800cde2:	61bb      	str	r3, [r7, #24]
   canfilterconfig.FilterScale = CAN_FILTERSCALE_32BIT;
 800cde4:	2301      	movs	r3, #1
 800cde6:	61fb      	str	r3, [r7, #28]
   canfilterconfig.SlaveStartFilterBank = 0;  // how many filters to assign to the CAN2 (slave can)
 800cde8:	2300      	movs	r3, #0
 800cdea:	627b      	str	r3, [r7, #36]	@ 0x24

   HAL_CAN_ConfigFilter(&hcan, &canfilterconfig);
 800cdec:	463b      	mov	r3, r7
 800cdee:	4619      	mov	r1, r3
 800cdf0:	4803      	ldr	r0, [pc, #12]	@ (800ce00 <MX_CAN_Init+0xa0>)
 800cdf2:	f000 fb2e 	bl	800d452 <HAL_CAN_ConfigFilter>
  /* USER CODE END CAN_Init 2 */

}
 800cdf6:	bf00      	nop
 800cdf8:	3728      	adds	r7, #40	@ 0x28
 800cdfa:	46bd      	mov	sp, r7
 800cdfc:	bd80      	pop	{r7, pc}
 800cdfe:	bf00      	nop
 800ce00:	2000002c 	.word	0x2000002c
 800ce04:	40006400 	.word	0x40006400

0800ce08 <MX_USART1_UART_Init>:
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{
 800ce08:	b580      	push	{r7, lr}
 800ce0a:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 800ce0c:	4b11      	ldr	r3, [pc, #68]	@ (800ce54 <MX_USART1_UART_Init+0x4c>)
 800ce0e:	4a12      	ldr	r2, [pc, #72]	@ (800ce58 <MX_USART1_UART_Init+0x50>)
 800ce10:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 9600;
 800ce12:	4b10      	ldr	r3, [pc, #64]	@ (800ce54 <MX_USART1_UART_Init+0x4c>)
 800ce14:	f44f 5216 	mov.w	r2, #9600	@ 0x2580
 800ce18:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 800ce1a:	4b0e      	ldr	r3, [pc, #56]	@ (800ce54 <MX_USART1_UART_Init+0x4c>)
 800ce1c:	2200      	movs	r2, #0
 800ce1e:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 800ce20:	4b0c      	ldr	r3, [pc, #48]	@ (800ce54 <MX_USART1_UART_Init+0x4c>)
 800ce22:	2200      	movs	r2, #0
 800ce24:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 800ce26:	4b0b      	ldr	r3, [pc, #44]	@ (800ce54 <MX_USART1_UART_Init+0x4c>)
 800ce28:	2200      	movs	r2, #0
 800ce2a:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 800ce2c:	4b09      	ldr	r3, [pc, #36]	@ (800ce54 <MX_USART1_UART_Init+0x4c>)
 800ce2e:	220c      	movs	r2, #12
 800ce30:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800ce32:	4b08      	ldr	r3, [pc, #32]	@ (800ce54 <MX_USART1_UART_Init+0x4c>)
 800ce34:	2200      	movs	r2, #0
 800ce36:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 800ce38:	4b06      	ldr	r3, [pc, #24]	@ (800ce54 <MX_USART1_UART_Init+0x4c>)
 800ce3a:	2200      	movs	r2, #0
 800ce3c:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 800ce3e:	4805      	ldr	r0, [pc, #20]	@ (800ce54 <MX_USART1_UART_Init+0x4c>)
 800ce40:	f001 fe38 	bl	800eab4 <HAL_UART_Init>
 800ce44:	4603      	mov	r3, r0
 800ce46:	2b00      	cmp	r3, #0
 800ce48:	d001      	beq.n	800ce4e <MX_USART1_UART_Init+0x46>
  {
    Error_Handler();
 800ce4a:	f000 f867 	bl	800cf1c <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 800ce4e:	bf00      	nop
 800ce50:	bd80      	pop	{r7, pc}
 800ce52:	bf00      	nop
 800ce54:	20000054 	.word	0x20000054
 800ce58:	40013800 	.word	0x40013800

0800ce5c <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 800ce5c:	b580      	push	{r7, lr}
 800ce5e:	b088      	sub	sp, #32
 800ce60:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800ce62:	f107 0310 	add.w	r3, r7, #16
 800ce66:	2200      	movs	r2, #0
 800ce68:	601a      	str	r2, [r3, #0]
 800ce6a:	605a      	str	r2, [r3, #4]
 800ce6c:	609a      	str	r2, [r3, #8]
 800ce6e:	60da      	str	r2, [r3, #12]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800ce70:	4b27      	ldr	r3, [pc, #156]	@ (800cf10 <MX_GPIO_Init+0xb4>)
 800ce72:	699b      	ldr	r3, [r3, #24]
 800ce74:	4a26      	ldr	r2, [pc, #152]	@ (800cf10 <MX_GPIO_Init+0xb4>)
 800ce76:	f043 0320 	orr.w	r3, r3, #32
 800ce7a:	6193      	str	r3, [r2, #24]
 800ce7c:	4b24      	ldr	r3, [pc, #144]	@ (800cf10 <MX_GPIO_Init+0xb4>)
 800ce7e:	699b      	ldr	r3, [r3, #24]
 800ce80:	f003 0320 	and.w	r3, r3, #32
 800ce84:	60fb      	str	r3, [r7, #12]
 800ce86:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800ce88:	4b21      	ldr	r3, [pc, #132]	@ (800cf10 <MX_GPIO_Init+0xb4>)
 800ce8a:	699b      	ldr	r3, [r3, #24]
 800ce8c:	4a20      	ldr	r2, [pc, #128]	@ (800cf10 <MX_GPIO_Init+0xb4>)
 800ce8e:	f043 0304 	orr.w	r3, r3, #4
 800ce92:	6193      	str	r3, [r2, #24]
 800ce94:	4b1e      	ldr	r3, [pc, #120]	@ (800cf10 <MX_GPIO_Init+0xb4>)
 800ce96:	699b      	ldr	r3, [r3, #24]
 800ce98:	f003 0304 	and.w	r3, r3, #4
 800ce9c:	60bb      	str	r3, [r7, #8]
 800ce9e:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800cea0:	4b1b      	ldr	r3, [pc, #108]	@ (800cf10 <MX_GPIO_Init+0xb4>)
 800cea2:	699b      	ldr	r3, [r3, #24]
 800cea4:	4a1a      	ldr	r2, [pc, #104]	@ (800cf10 <MX_GPIO_Init+0xb4>)
 800cea6:	f043 0308 	orr.w	r3, r3, #8
 800ceaa:	6193      	str	r3, [r2, #24]
 800ceac:	4b18      	ldr	r3, [pc, #96]	@ (800cf10 <MX_GPIO_Init+0xb4>)
 800ceae:	699b      	ldr	r3, [r3, #24]
 800ceb0:	f003 0308 	and.w	r3, r3, #8
 800ceb4:	607b      	str	r3, [r7, #4]
 800ceb6:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 800ceb8:	2200      	movs	r2, #0
 800ceba:	216f      	movs	r1, #111	@ 0x6f
 800cebc:	4815      	ldr	r0, [pc, #84]	@ (800cf14 <MX_GPIO_Init+0xb8>)
 800cebe:	f001 f9b7 	bl	800e230 <HAL_GPIO_WritePin>
                          |GPIO_PIN_5|GPIO_PIN_6, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
 800cec2:	2200      	movs	r2, #0
 800cec4:	f44f 4174 	mov.w	r1, #62464	@ 0xf400
 800cec8:	4813      	ldr	r0, [pc, #76]	@ (800cf18 <MX_GPIO_Init+0xbc>)
 800ceca:	f001 f9b1 	bl	800e230 <HAL_GPIO_WritePin>
                          |GPIO_PIN_15, GPIO_PIN_RESET);

  /*Configure GPIO pins : PA0 PA1 PA2 PA3
                           PA5 PA6 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 800cece:	236f      	movs	r3, #111	@ 0x6f
 800ced0:	613b      	str	r3, [r7, #16]
                          |GPIO_PIN_5|GPIO_PIN_6;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800ced2:	2301      	movs	r3, #1
 800ced4:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ced6:	2300      	movs	r3, #0
 800ced8:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800ceda:	2302      	movs	r3, #2
 800cedc:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800cede:	f107 0310 	add.w	r3, r7, #16
 800cee2:	4619      	mov	r1, r3
 800cee4:	480b      	ldr	r0, [pc, #44]	@ (800cf14 <MX_GPIO_Init+0xb8>)
 800cee6:	f001 f81f 	bl	800df28 <HAL_GPIO_Init>

  /*Configure GPIO pins : PB10 PB12 PB13 PB14
                           PB15 */
  GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
 800ceea:	f44f 4374 	mov.w	r3, #62464	@ 0xf400
 800ceee:	613b      	str	r3, [r7, #16]
                          |GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800cef0:	2301      	movs	r3, #1
 800cef2:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800cef4:	2300      	movs	r3, #0
 800cef6:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800cef8:	2302      	movs	r3, #2
 800cefa:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800cefc:	f107 0310 	add.w	r3, r7, #16
 800cf00:	4619      	mov	r1, r3
 800cf02:	4805      	ldr	r0, [pc, #20]	@ (800cf18 <MX_GPIO_Init+0xbc>)
 800cf04:	f001 f810 	bl	800df28 <HAL_GPIO_Init>

}
 800cf08:	bf00      	nop
 800cf0a:	3720      	adds	r7, #32
 800cf0c:	46bd      	mov	sp, r7
 800cf0e:	bd80      	pop	{r7, pc}
 800cf10:	40021000 	.word	0x40021000
 800cf14:	40010800 	.word	0x40010800
 800cf18:	40010c00 	.word	0x40010c00

0800cf1c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800cf1c:	b480      	push	{r7}
 800cf1e:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 800cf20:	b672      	cpsid	i
}
 800cf22:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800cf24:	bf00      	nop
 800cf26:	e7fd      	b.n	800cf24 <Error_Handler+0x8>

0800cf28 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800cf28:	b480      	push	{r7}
 800cf2a:	b083      	sub	sp, #12
 800cf2c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 800cf2e:	4b0e      	ldr	r3, [pc, #56]	@ (800cf68 <HAL_MspInit+0x40>)
 800cf30:	699b      	ldr	r3, [r3, #24]
 800cf32:	4a0d      	ldr	r2, [pc, #52]	@ (800cf68 <HAL_MspInit+0x40>)
 800cf34:	f043 0301 	orr.w	r3, r3, #1
 800cf38:	6193      	str	r3, [r2, #24]
 800cf3a:	4b0b      	ldr	r3, [pc, #44]	@ (800cf68 <HAL_MspInit+0x40>)
 800cf3c:	699b      	ldr	r3, [r3, #24]
 800cf3e:	f003 0301 	and.w	r3, r3, #1
 800cf42:	607b      	str	r3, [r7, #4]
 800cf44:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800cf46:	4b08      	ldr	r3, [pc, #32]	@ (800cf68 <HAL_MspInit+0x40>)
 800cf48:	69db      	ldr	r3, [r3, #28]
 800cf4a:	4a07      	ldr	r2, [pc, #28]	@ (800cf68 <HAL_MspInit+0x40>)
 800cf4c:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800cf50:	61d3      	str	r3, [r2, #28]
 800cf52:	4b05      	ldr	r3, [pc, #20]	@ (800cf68 <HAL_MspInit+0x40>)
 800cf54:	69db      	ldr	r3, [r3, #28]
 800cf56:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800cf5a:	603b      	str	r3, [r7, #0]
 800cf5c:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800cf5e:	bf00      	nop
 800cf60:	370c      	adds	r7, #12
 800cf62:	46bd      	mov	sp, r7
 800cf64:	bc80      	pop	{r7}
 800cf66:	4770      	bx	lr
 800cf68:	40021000 	.word	0x40021000

0800cf6c <HAL_CAN_MspInit>:
* This function configures the hardware resources used in this example
* @param hcan: CAN handle pointer
* @retval None
*/
void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)
{
 800cf6c:	b580      	push	{r7, lr}
 800cf6e:	b08a      	sub	sp, #40	@ 0x28
 800cf70:	af00      	add	r7, sp, #0
 800cf72:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800cf74:	f107 0314 	add.w	r3, r7, #20
 800cf78:	2200      	movs	r2, #0
 800cf7a:	601a      	str	r2, [r3, #0]
 800cf7c:	605a      	str	r2, [r3, #4]
 800cf7e:	609a      	str	r2, [r3, #8]
 800cf80:	60da      	str	r2, [r3, #12]
  if(hcan->Instance==CAN1)
 800cf82:	687b      	ldr	r3, [r7, #4]
 800cf84:	681b      	ldr	r3, [r3, #0]
 800cf86:	4a29      	ldr	r2, [pc, #164]	@ (800d02c <HAL_CAN_MspInit+0xc0>)
 800cf88:	4293      	cmp	r3, r2
 800cf8a:	d14b      	bne.n	800d024 <HAL_CAN_MspInit+0xb8>
  {
  /* USER CODE BEGIN CAN1_MspInit 0 */

  /* USER CODE END CAN1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CAN1_CLK_ENABLE();
 800cf8c:	4b28      	ldr	r3, [pc, #160]	@ (800d030 <HAL_CAN_MspInit+0xc4>)
 800cf8e:	69db      	ldr	r3, [r3, #28]
 800cf90:	4a27      	ldr	r2, [pc, #156]	@ (800d030 <HAL_CAN_MspInit+0xc4>)
 800cf92:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 800cf96:	61d3      	str	r3, [r2, #28]
 800cf98:	4b25      	ldr	r3, [pc, #148]	@ (800d030 <HAL_CAN_MspInit+0xc4>)
 800cf9a:	69db      	ldr	r3, [r3, #28]
 800cf9c:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800cfa0:	613b      	str	r3, [r7, #16]
 800cfa2:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOB_CLK_ENABLE();
 800cfa4:	4b22      	ldr	r3, [pc, #136]	@ (800d030 <HAL_CAN_MspInit+0xc4>)
 800cfa6:	699b      	ldr	r3, [r3, #24]
 800cfa8:	4a21      	ldr	r2, [pc, #132]	@ (800d030 <HAL_CAN_MspInit+0xc4>)
 800cfaa:	f043 0308 	orr.w	r3, r3, #8
 800cfae:	6193      	str	r3, [r2, #24]
 800cfb0:	4b1f      	ldr	r3, [pc, #124]	@ (800d030 <HAL_CAN_MspInit+0xc4>)
 800cfb2:	699b      	ldr	r3, [r3, #24]
 800cfb4:	f003 0308 	and.w	r3, r3, #8
 800cfb8:	60fb      	str	r3, [r7, #12]
 800cfba:	68fb      	ldr	r3, [r7, #12]
    /**CAN GPIO Configuration
    PB8     ------> CAN_RX
    PB9     ------> CAN_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8;
 800cfbc:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800cfc0:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800cfc2:	2300      	movs	r3, #0
 800cfc4:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800cfc6:	2300      	movs	r3, #0
 800cfc8:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800cfca:	f107 0314 	add.w	r3, r7, #20
 800cfce:	4619      	mov	r1, r3
 800cfd0:	4818      	ldr	r0, [pc, #96]	@ (800d034 <HAL_CAN_MspInit+0xc8>)
 800cfd2:	f000 ffa9 	bl	800df28 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9;
 800cfd6:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800cfda:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800cfdc:	2302      	movs	r3, #2
 800cfde:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800cfe0:	2303      	movs	r3, #3
 800cfe2:	623b      	str	r3, [r7, #32]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800cfe4:	f107 0314 	add.w	r3, r7, #20
 800cfe8:	4619      	mov	r1, r3
 800cfea:	4812      	ldr	r0, [pc, #72]	@ (800d034 <HAL_CAN_MspInit+0xc8>)
 800cfec:	f000 ff9c 	bl	800df28 <HAL_GPIO_Init>

    __HAL_AFIO_REMAP_CAN1_2();
 800cff0:	4b11      	ldr	r3, [pc, #68]	@ (800d038 <HAL_CAN_MspInit+0xcc>)
 800cff2:	685b      	ldr	r3, [r3, #4]
 800cff4:	627b      	str	r3, [r7, #36]	@ 0x24
 800cff6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cff8:	f423 43c0 	bic.w	r3, r3, #24576	@ 0x6000
 800cffc:	627b      	str	r3, [r7, #36]	@ 0x24
 800cffe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d000:	f043 63e0 	orr.w	r3, r3, #117440512	@ 0x7000000
 800d004:	627b      	str	r3, [r7, #36]	@ 0x24
 800d006:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d008:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800d00c:	627b      	str	r3, [r7, #36]	@ 0x24
 800d00e:	4a0a      	ldr	r2, [pc, #40]	@ (800d038 <HAL_CAN_MspInit+0xcc>)
 800d010:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d012:	6053      	str	r3, [r2, #4]

    /* CAN1 interrupt Init */
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 0, 0);
 800d014:	2200      	movs	r2, #0
 800d016:	2100      	movs	r1, #0
 800d018:	2014      	movs	r0, #20
 800d01a:	f000 ff4e 	bl	800deba <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
 800d01e:	2014      	movs	r0, #20
 800d020:	f000 ff67 	bl	800def2 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN CAN1_MspInit 1 */

  /* USER CODE END CAN1_MspInit 1 */
  }

}
 800d024:	bf00      	nop
 800d026:	3728      	adds	r7, #40	@ 0x28
 800d028:	46bd      	mov	sp, r7
 800d02a:	bd80      	pop	{r7, pc}
 800d02c:	40006400 	.word	0x40006400
 800d030:	40021000 	.word	0x40021000
 800d034:	40010c00 	.word	0x40010c00
 800d038:	40010000 	.word	0x40010000

0800d03c <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 800d03c:	b580      	push	{r7, lr}
 800d03e:	b088      	sub	sp, #32
 800d040:	af00      	add	r7, sp, #0
 800d042:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800d044:	f107 0310 	add.w	r3, r7, #16
 800d048:	2200      	movs	r2, #0
 800d04a:	601a      	str	r2, [r3, #0]
 800d04c:	605a      	str	r2, [r3, #4]
 800d04e:	609a      	str	r2, [r3, #8]
 800d050:	60da      	str	r2, [r3, #12]
  if(huart->Instance==USART1)
 800d052:	687b      	ldr	r3, [r7, #4]
 800d054:	681b      	ldr	r3, [r3, #0]
 800d056:	4a1c      	ldr	r2, [pc, #112]	@ (800d0c8 <HAL_UART_MspInit+0x8c>)
 800d058:	4293      	cmp	r3, r2
 800d05a:	d131      	bne.n	800d0c0 <HAL_UART_MspInit+0x84>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 800d05c:	4b1b      	ldr	r3, [pc, #108]	@ (800d0cc <HAL_UART_MspInit+0x90>)
 800d05e:	699b      	ldr	r3, [r3, #24]
 800d060:	4a1a      	ldr	r2, [pc, #104]	@ (800d0cc <HAL_UART_MspInit+0x90>)
 800d062:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800d066:	6193      	str	r3, [r2, #24]
 800d068:	4b18      	ldr	r3, [pc, #96]	@ (800d0cc <HAL_UART_MspInit+0x90>)
 800d06a:	699b      	ldr	r3, [r3, #24]
 800d06c:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800d070:	60fb      	str	r3, [r7, #12]
 800d072:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800d074:	4b15      	ldr	r3, [pc, #84]	@ (800d0cc <HAL_UART_MspInit+0x90>)
 800d076:	699b      	ldr	r3, [r3, #24]
 800d078:	4a14      	ldr	r2, [pc, #80]	@ (800d0cc <HAL_UART_MspInit+0x90>)
 800d07a:	f043 0304 	orr.w	r3, r3, #4
 800d07e:	6193      	str	r3, [r2, #24]
 800d080:	4b12      	ldr	r3, [pc, #72]	@ (800d0cc <HAL_UART_MspInit+0x90>)
 800d082:	699b      	ldr	r3, [r3, #24]
 800d084:	f003 0304 	and.w	r3, r3, #4
 800d088:	60bb      	str	r3, [r7, #8]
 800d08a:	68bb      	ldr	r3, [r7, #8]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 800d08c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800d090:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800d092:	2302      	movs	r3, #2
 800d094:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800d096:	2303      	movs	r3, #3
 800d098:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800d09a:	f107 0310 	add.w	r3, r7, #16
 800d09e:	4619      	mov	r1, r3
 800d0a0:	480b      	ldr	r0, [pc, #44]	@ (800d0d0 <HAL_UART_MspInit+0x94>)
 800d0a2:	f000 ff41 	bl	800df28 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
 800d0a6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800d0aa:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800d0ac:	2300      	movs	r3, #0
 800d0ae:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800d0b0:	2300      	movs	r3, #0
 800d0b2:	61bb      	str	r3, [r7, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800d0b4:	f107 0310 	add.w	r3, r7, #16
 800d0b8:	4619      	mov	r1, r3
 800d0ba:	4805      	ldr	r0, [pc, #20]	@ (800d0d0 <HAL_UART_MspInit+0x94>)
 800d0bc:	f000 ff34 	bl	800df28 <HAL_GPIO_Init>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }

}
 800d0c0:	bf00      	nop
 800d0c2:	3720      	adds	r7, #32
 800d0c4:	46bd      	mov	sp, r7
 800d0c6:	bd80      	pop	{r7, pc}
 800d0c8:	40013800 	.word	0x40013800
 800d0cc:	40021000 	.word	0x40021000
 800d0d0:	40010800 	.word	0x40010800

0800d0d4 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800d0d4:	b480      	push	{r7}
 800d0d6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 800d0d8:	bf00      	nop
 800d0da:	e7fd      	b.n	800d0d8 <NMI_Handler+0x4>

0800d0dc <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800d0dc:	b480      	push	{r7}
 800d0de:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800d0e0:	bf00      	nop
 800d0e2:	e7fd      	b.n	800d0e0 <HardFault_Handler+0x4>

0800d0e4 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800d0e4:	b480      	push	{r7}
 800d0e6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800d0e8:	bf00      	nop
 800d0ea:	e7fd      	b.n	800d0e8 <MemManage_Handler+0x4>

0800d0ec <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800d0ec:	b480      	push	{r7}
 800d0ee:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800d0f0:	bf00      	nop
 800d0f2:	e7fd      	b.n	800d0f0 <BusFault_Handler+0x4>

0800d0f4 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800d0f4:	b480      	push	{r7}
 800d0f6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800d0f8:	bf00      	nop
 800d0fa:	e7fd      	b.n	800d0f8 <UsageFault_Handler+0x4>

0800d0fc <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800d0fc:	b480      	push	{r7}
 800d0fe:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800d100:	bf00      	nop
 800d102:	46bd      	mov	sp, r7
 800d104:	bc80      	pop	{r7}
 800d106:	4770      	bx	lr

0800d108 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800d108:	b480      	push	{r7}
 800d10a:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800d10c:	bf00      	nop
 800d10e:	46bd      	mov	sp, r7
 800d110:	bc80      	pop	{r7}
 800d112:	4770      	bx	lr

0800d114 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800d114:	b480      	push	{r7}
 800d116:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800d118:	bf00      	nop
 800d11a:	46bd      	mov	sp, r7
 800d11c:	bc80      	pop	{r7}
 800d11e:	4770      	bx	lr

0800d120 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800d120:	b580      	push	{r7, lr}
 800d122:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800d124:	f000 f87e 	bl	800d224 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800d128:	bf00      	nop
 800d12a:	bd80      	pop	{r7, pc}

0800d12c <USB_LP_CAN1_RX0_IRQHandler>:

/**
  * @brief This function handles USB low priority or CAN RX0 interrupts.
  */
void USB_LP_CAN1_RX0_IRQHandler(void)
{
 800d12c:	b580      	push	{r7, lr}
 800d12e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_LP_CAN1_RX0_IRQn 0 */

  /* USER CODE END USB_LP_CAN1_RX0_IRQn 0 */
  HAL_CAN_IRQHandler(&hcan);
 800d130:	4802      	ldr	r0, [pc, #8]	@ (800d13c <USB_LP_CAN1_RX0_IRQHandler+0x10>)
 800d132:	f000 fbc8 	bl	800d8c6 <HAL_CAN_IRQHandler>
  /* USER CODE BEGIN USB_LP_CAN1_RX0_IRQn 1 */

  /* USER CODE END USB_LP_CAN1_RX0_IRQn 1 */
}
 800d136:	bf00      	nop
 800d138:	bd80      	pop	{r7, pc}
 800d13a:	bf00      	nop
 800d13c:	2000002c 	.word	0x2000002c

0800d140 <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 800d140:	b480      	push	{r7}
 800d142:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#endif /* USER_VECT_TAB_ADDRESS */
}
 800d144:	bf00      	nop
 800d146:	46bd      	mov	sp, r7
 800d148:	bc80      	pop	{r7}
 800d14a:	4770      	bx	lr

0800d14c <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Call the clock system initialization function.*/
    bl  SystemInit
 800d14c:	f7ff fff8 	bl	800d140 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800d150:	480b      	ldr	r0, [pc, #44]	@ (800d180 <LoopFillZerobss+0xe>)
  ldr r1, =_edata
 800d152:	490c      	ldr	r1, [pc, #48]	@ (800d184 <LoopFillZerobss+0x12>)
  ldr r2, =_sidata
 800d154:	4a0c      	ldr	r2, [pc, #48]	@ (800d188 <LoopFillZerobss+0x16>)
  movs r3, #0
 800d156:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800d158:	e002      	b.n	800d160 <LoopCopyDataInit>

0800d15a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800d15a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800d15c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800d15e:	3304      	adds	r3, #4

0800d160 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800d160:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800d162:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800d164:	d3f9      	bcc.n	800d15a <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800d166:	4a09      	ldr	r2, [pc, #36]	@ (800d18c <LoopFillZerobss+0x1a>)
  ldr r4, =_ebss
 800d168:	4c09      	ldr	r4, [pc, #36]	@ (800d190 <LoopFillZerobss+0x1e>)
  movs r3, #0
 800d16a:	2300      	movs	r3, #0
  b LoopFillZerobss
 800d16c:	e001      	b.n	800d172 <LoopFillZerobss>

0800d16e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800d16e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800d170:	3204      	adds	r2, #4

0800d172 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800d172:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800d174:	d3fb      	bcc.n	800d16e <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 800d176:	f001 fe83 	bl	800ee80 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800d17a:	f7ff fd37 	bl	800cbec <main>
  bx lr
 800d17e:	4770      	bx	lr
  ldr r0, =_sdata
 800d180:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800d184:	20000010 	.word	0x20000010
  ldr r2, =_sidata
 800d188:	0800ef14 	.word	0x0800ef14
  ldr r2, =_sbss
 800d18c:	20000010 	.word	0x20000010
  ldr r4, =_ebss
 800d190:	200000cc 	.word	0x200000cc

0800d194 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800d194:	e7fe      	b.n	800d194 <ADC1_2_IRQHandler>
	...

0800d198 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800d198:	b580      	push	{r7, lr}
 800d19a:	af00      	add	r7, sp, #0
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800d19c:	4b08      	ldr	r3, [pc, #32]	@ (800d1c0 <HAL_Init+0x28>)
 800d19e:	681b      	ldr	r3, [r3, #0]
 800d1a0:	4a07      	ldr	r2, [pc, #28]	@ (800d1c0 <HAL_Init+0x28>)
 800d1a2:	f043 0310 	orr.w	r3, r3, #16
 800d1a6:	6013      	str	r3, [r2, #0]
#endif
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800d1a8:	2003      	movs	r0, #3
 800d1aa:	f000 fe7b 	bl	800dea4 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800d1ae:	200f      	movs	r0, #15
 800d1b0:	f000 f808 	bl	800d1c4 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800d1b4:	f7ff feb8 	bl	800cf28 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800d1b8:	2300      	movs	r3, #0
}
 800d1ba:	4618      	mov	r0, r3
 800d1bc:	bd80      	pop	{r7, pc}
 800d1be:	bf00      	nop
 800d1c0:	40022000 	.word	0x40022000

0800d1c4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800d1c4:	b580      	push	{r7, lr}
 800d1c6:	b082      	sub	sp, #8
 800d1c8:	af00      	add	r7, sp, #0
 800d1ca:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800d1cc:	4b12      	ldr	r3, [pc, #72]	@ (800d218 <HAL_InitTick+0x54>)
 800d1ce:	681a      	ldr	r2, [r3, #0]
 800d1d0:	4b12      	ldr	r3, [pc, #72]	@ (800d21c <HAL_InitTick+0x58>)
 800d1d2:	781b      	ldrb	r3, [r3, #0]
 800d1d4:	4619      	mov	r1, r3
 800d1d6:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800d1da:	fbb3 f3f1 	udiv	r3, r3, r1
 800d1de:	fbb2 f3f3 	udiv	r3, r2, r3
 800d1e2:	4618      	mov	r0, r3
 800d1e4:	f000 fe93 	bl	800df0e <HAL_SYSTICK_Config>
 800d1e8:	4603      	mov	r3, r0
 800d1ea:	2b00      	cmp	r3, #0
 800d1ec:	d001      	beq.n	800d1f2 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 800d1ee:	2301      	movs	r3, #1
 800d1f0:	e00e      	b.n	800d210 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800d1f2:	687b      	ldr	r3, [r7, #4]
 800d1f4:	2b0f      	cmp	r3, #15
 800d1f6:	d80a      	bhi.n	800d20e <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800d1f8:	2200      	movs	r2, #0
 800d1fa:	6879      	ldr	r1, [r7, #4]
 800d1fc:	f04f 30ff 	mov.w	r0, #4294967295
 800d200:	f000 fe5b 	bl	800deba <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800d204:	4a06      	ldr	r2, [pc, #24]	@ (800d220 <HAL_InitTick+0x5c>)
 800d206:	687b      	ldr	r3, [r7, #4]
 800d208:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 800d20a:	2300      	movs	r3, #0
 800d20c:	e000      	b.n	800d210 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 800d20e:	2301      	movs	r3, #1
}
 800d210:	4618      	mov	r0, r3
 800d212:	3708      	adds	r7, #8
 800d214:	46bd      	mov	sp, r7
 800d216:	bd80      	pop	{r7, pc}
 800d218:	20000004 	.word	0x20000004
 800d21c:	2000000c 	.word	0x2000000c
 800d220:	20000008 	.word	0x20000008

0800d224 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800d224:	b480      	push	{r7}
 800d226:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 800d228:	4b05      	ldr	r3, [pc, #20]	@ (800d240 <HAL_IncTick+0x1c>)
 800d22a:	781b      	ldrb	r3, [r3, #0]
 800d22c:	461a      	mov	r2, r3
 800d22e:	4b05      	ldr	r3, [pc, #20]	@ (800d244 <HAL_IncTick+0x20>)
 800d230:	681b      	ldr	r3, [r3, #0]
 800d232:	4413      	add	r3, r2
 800d234:	4a03      	ldr	r2, [pc, #12]	@ (800d244 <HAL_IncTick+0x20>)
 800d236:	6013      	str	r3, [r2, #0]
}
 800d238:	bf00      	nop
 800d23a:	46bd      	mov	sp, r7
 800d23c:	bc80      	pop	{r7}
 800d23e:	4770      	bx	lr
 800d240:	2000000c 	.word	0x2000000c
 800d244:	200000c8 	.word	0x200000c8

0800d248 <HAL_GetTick>:
  * @note  This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800d248:	b480      	push	{r7}
 800d24a:	af00      	add	r7, sp, #0
  return uwTick;
 800d24c:	4b02      	ldr	r3, [pc, #8]	@ (800d258 <HAL_GetTick+0x10>)
 800d24e:	681b      	ldr	r3, [r3, #0]
}
 800d250:	4618      	mov	r0, r3
 800d252:	46bd      	mov	sp, r7
 800d254:	bc80      	pop	{r7}
 800d256:	4770      	bx	lr
 800d258:	200000c8 	.word	0x200000c8

0800d25c <HAL_CAN_Init>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan)
{
 800d25c:	b580      	push	{r7, lr}
 800d25e:	b084      	sub	sp, #16
 800d260:	af00      	add	r7, sp, #0
 800d262:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check CAN handle */
  if (hcan == NULL)
 800d264:	687b      	ldr	r3, [r7, #4]
 800d266:	2b00      	cmp	r3, #0
 800d268:	d101      	bne.n	800d26e <HAL_CAN_Init+0x12>
  {
    return HAL_ERROR;
 800d26a:	2301      	movs	r3, #1
 800d26c:	e0ed      	b.n	800d44a <HAL_CAN_Init+0x1ee>
    /* Init the low level hardware: CLOCK, NVIC */
    hcan->MspInitCallback(hcan);
  }

#else
  if (hcan->State == HAL_CAN_STATE_RESET)
 800d26e:	687b      	ldr	r3, [r7, #4]
 800d270:	f893 3020 	ldrb.w	r3, [r3, #32]
 800d274:	b2db      	uxtb	r3, r3
 800d276:	2b00      	cmp	r3, #0
 800d278:	d102      	bne.n	800d280 <HAL_CAN_Init+0x24>
  {
    /* Init the low level hardware: CLOCK, NVIC */
    HAL_CAN_MspInit(hcan);
 800d27a:	6878      	ldr	r0, [r7, #4]
 800d27c:	f7ff fe76 	bl	800cf6c <HAL_CAN_MspInit>
  }
#endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */

  /* Request initialisation */
  SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 800d280:	687b      	ldr	r3, [r7, #4]
 800d282:	681b      	ldr	r3, [r3, #0]
 800d284:	681a      	ldr	r2, [r3, #0]
 800d286:	687b      	ldr	r3, [r7, #4]
 800d288:	681b      	ldr	r3, [r3, #0]
 800d28a:	f042 0201 	orr.w	r2, r2, #1
 800d28e:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800d290:	f7ff ffda 	bl	800d248 <HAL_GetTick>
 800d294:	60f8      	str	r0, [r7, #12]

  /* Wait initialisation acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
 800d296:	e012      	b.n	800d2be <HAL_CAN_Init+0x62>
  {
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 800d298:	f7ff ffd6 	bl	800d248 <HAL_GetTick>
 800d29c:	4602      	mov	r2, r0
 800d29e:	68fb      	ldr	r3, [r7, #12]
 800d2a0:	1ad3      	subs	r3, r2, r3
 800d2a2:	2b0a      	cmp	r3, #10
 800d2a4:	d90b      	bls.n	800d2be <HAL_CAN_Init+0x62>
    {
      /* Update error code */
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 800d2a6:	687b      	ldr	r3, [r7, #4]
 800d2a8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d2aa:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
 800d2ae:	687b      	ldr	r3, [r7, #4]
 800d2b0:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_ERROR;
 800d2b2:	687b      	ldr	r3, [r7, #4]
 800d2b4:	2205      	movs	r2, #5
 800d2b6:	f883 2020 	strb.w	r2, [r3, #32]

      return HAL_ERROR;
 800d2ba:	2301      	movs	r3, #1
 800d2bc:	e0c5      	b.n	800d44a <HAL_CAN_Init+0x1ee>
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
 800d2be:	687b      	ldr	r3, [r7, #4]
 800d2c0:	681b      	ldr	r3, [r3, #0]
 800d2c2:	685b      	ldr	r3, [r3, #4]
 800d2c4:	f003 0301 	and.w	r3, r3, #1
 800d2c8:	2b00      	cmp	r3, #0
 800d2ca:	d0e5      	beq.n	800d298 <HAL_CAN_Init+0x3c>
    }
  }

  /* Exit from sleep mode */
  CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
 800d2cc:	687b      	ldr	r3, [r7, #4]
 800d2ce:	681b      	ldr	r3, [r3, #0]
 800d2d0:	681a      	ldr	r2, [r3, #0]
 800d2d2:	687b      	ldr	r3, [r7, #4]
 800d2d4:	681b      	ldr	r3, [r3, #0]
 800d2d6:	f022 0202 	bic.w	r2, r2, #2
 800d2da:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800d2dc:	f7ff ffb4 	bl	800d248 <HAL_GetTick>
 800d2e0:	60f8      	str	r0, [r7, #12]

  /* Check Sleep mode leave acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
 800d2e2:	e012      	b.n	800d30a <HAL_CAN_Init+0xae>
  {
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 800d2e4:	f7ff ffb0 	bl	800d248 <HAL_GetTick>
 800d2e8:	4602      	mov	r2, r0
 800d2ea:	68fb      	ldr	r3, [r7, #12]
 800d2ec:	1ad3      	subs	r3, r2, r3
 800d2ee:	2b0a      	cmp	r3, #10
 800d2f0:	d90b      	bls.n	800d30a <HAL_CAN_Init+0xae>
    {
      /* Update error code */
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 800d2f2:	687b      	ldr	r3, [r7, #4]
 800d2f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d2f6:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
 800d2fa:	687b      	ldr	r3, [r7, #4]
 800d2fc:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_ERROR;
 800d2fe:	687b      	ldr	r3, [r7, #4]
 800d300:	2205      	movs	r2, #5
 800d302:	f883 2020 	strb.w	r2, [r3, #32]

      return HAL_ERROR;
 800d306:	2301      	movs	r3, #1
 800d308:	e09f      	b.n	800d44a <HAL_CAN_Init+0x1ee>
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
 800d30a:	687b      	ldr	r3, [r7, #4]
 800d30c:	681b      	ldr	r3, [r3, #0]
 800d30e:	685b      	ldr	r3, [r3, #4]
 800d310:	f003 0302 	and.w	r3, r3, #2
 800d314:	2b00      	cmp	r3, #0
 800d316:	d1e5      	bne.n	800d2e4 <HAL_CAN_Init+0x88>
    }
  }

  /* Set the time triggered communication mode */
  if (hcan->Init.TimeTriggeredMode == ENABLE)
 800d318:	687b      	ldr	r3, [r7, #4]
 800d31a:	7e1b      	ldrb	r3, [r3, #24]
 800d31c:	2b01      	cmp	r3, #1
 800d31e:	d108      	bne.n	800d332 <HAL_CAN_Init+0xd6>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 800d320:	687b      	ldr	r3, [r7, #4]
 800d322:	681b      	ldr	r3, [r3, #0]
 800d324:	681a      	ldr	r2, [r3, #0]
 800d326:	687b      	ldr	r3, [r7, #4]
 800d328:	681b      	ldr	r3, [r3, #0]
 800d32a:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 800d32e:	601a      	str	r2, [r3, #0]
 800d330:	e007      	b.n	800d342 <HAL_CAN_Init+0xe6>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 800d332:	687b      	ldr	r3, [r7, #4]
 800d334:	681b      	ldr	r3, [r3, #0]
 800d336:	681a      	ldr	r2, [r3, #0]
 800d338:	687b      	ldr	r3, [r7, #4]
 800d33a:	681b      	ldr	r3, [r3, #0]
 800d33c:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 800d340:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic bus-off management */
  if (hcan->Init.AutoBusOff == ENABLE)
 800d342:	687b      	ldr	r3, [r7, #4]
 800d344:	7e5b      	ldrb	r3, [r3, #25]
 800d346:	2b01      	cmp	r3, #1
 800d348:	d108      	bne.n	800d35c <HAL_CAN_Init+0x100>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 800d34a:	687b      	ldr	r3, [r7, #4]
 800d34c:	681b      	ldr	r3, [r3, #0]
 800d34e:	681a      	ldr	r2, [r3, #0]
 800d350:	687b      	ldr	r3, [r7, #4]
 800d352:	681b      	ldr	r3, [r3, #0]
 800d354:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800d358:	601a      	str	r2, [r3, #0]
 800d35a:	e007      	b.n	800d36c <HAL_CAN_Init+0x110>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 800d35c:	687b      	ldr	r3, [r7, #4]
 800d35e:	681b      	ldr	r3, [r3, #0]
 800d360:	681a      	ldr	r2, [r3, #0]
 800d362:	687b      	ldr	r3, [r7, #4]
 800d364:	681b      	ldr	r3, [r3, #0]
 800d366:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 800d36a:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic wake-up mode */
  if (hcan->Init.AutoWakeUp == ENABLE)
 800d36c:	687b      	ldr	r3, [r7, #4]
 800d36e:	7e9b      	ldrb	r3, [r3, #26]
 800d370:	2b01      	cmp	r3, #1
 800d372:	d108      	bne.n	800d386 <HAL_CAN_Init+0x12a>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 800d374:	687b      	ldr	r3, [r7, #4]
 800d376:	681b      	ldr	r3, [r3, #0]
 800d378:	681a      	ldr	r2, [r3, #0]
 800d37a:	687b      	ldr	r3, [r7, #4]
 800d37c:	681b      	ldr	r3, [r3, #0]
 800d37e:	f042 0220 	orr.w	r2, r2, #32
 800d382:	601a      	str	r2, [r3, #0]
 800d384:	e007      	b.n	800d396 <HAL_CAN_Init+0x13a>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 800d386:	687b      	ldr	r3, [r7, #4]
 800d388:	681b      	ldr	r3, [r3, #0]
 800d38a:	681a      	ldr	r2, [r3, #0]
 800d38c:	687b      	ldr	r3, [r7, #4]
 800d38e:	681b      	ldr	r3, [r3, #0]
 800d390:	f022 0220 	bic.w	r2, r2, #32
 800d394:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic retransmission */
  if (hcan->Init.AutoRetransmission == ENABLE)
 800d396:	687b      	ldr	r3, [r7, #4]
 800d398:	7edb      	ldrb	r3, [r3, #27]
 800d39a:	2b01      	cmp	r3, #1
 800d39c:	d108      	bne.n	800d3b0 <HAL_CAN_Init+0x154>
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 800d39e:	687b      	ldr	r3, [r7, #4]
 800d3a0:	681b      	ldr	r3, [r3, #0]
 800d3a2:	681a      	ldr	r2, [r3, #0]
 800d3a4:	687b      	ldr	r3, [r7, #4]
 800d3a6:	681b      	ldr	r3, [r3, #0]
 800d3a8:	f022 0210 	bic.w	r2, r2, #16
 800d3ac:	601a      	str	r2, [r3, #0]
 800d3ae:	e007      	b.n	800d3c0 <HAL_CAN_Init+0x164>
  }
  else
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 800d3b0:	687b      	ldr	r3, [r7, #4]
 800d3b2:	681b      	ldr	r3, [r3, #0]
 800d3b4:	681a      	ldr	r2, [r3, #0]
 800d3b6:	687b      	ldr	r3, [r7, #4]
 800d3b8:	681b      	ldr	r3, [r3, #0]
 800d3ba:	f042 0210 	orr.w	r2, r2, #16
 800d3be:	601a      	str	r2, [r3, #0]
  }

  /* Set the receive FIFO locked mode */
  if (hcan->Init.ReceiveFifoLocked == ENABLE)
 800d3c0:	687b      	ldr	r3, [r7, #4]
 800d3c2:	7f1b      	ldrb	r3, [r3, #28]
 800d3c4:	2b01      	cmp	r3, #1
 800d3c6:	d108      	bne.n	800d3da <HAL_CAN_Init+0x17e>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 800d3c8:	687b      	ldr	r3, [r7, #4]
 800d3ca:	681b      	ldr	r3, [r3, #0]
 800d3cc:	681a      	ldr	r2, [r3, #0]
 800d3ce:	687b      	ldr	r3, [r7, #4]
 800d3d0:	681b      	ldr	r3, [r3, #0]
 800d3d2:	f042 0208 	orr.w	r2, r2, #8
 800d3d6:	601a      	str	r2, [r3, #0]
 800d3d8:	e007      	b.n	800d3ea <HAL_CAN_Init+0x18e>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 800d3da:	687b      	ldr	r3, [r7, #4]
 800d3dc:	681b      	ldr	r3, [r3, #0]
 800d3de:	681a      	ldr	r2, [r3, #0]
 800d3e0:	687b      	ldr	r3, [r7, #4]
 800d3e2:	681b      	ldr	r3, [r3, #0]
 800d3e4:	f022 0208 	bic.w	r2, r2, #8
 800d3e8:	601a      	str	r2, [r3, #0]
  }

  /* Set the transmit FIFO priority */
  if (hcan->Init.TransmitFifoPriority == ENABLE)
 800d3ea:	687b      	ldr	r3, [r7, #4]
 800d3ec:	7f5b      	ldrb	r3, [r3, #29]
 800d3ee:	2b01      	cmp	r3, #1
 800d3f0:	d108      	bne.n	800d404 <HAL_CAN_Init+0x1a8>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 800d3f2:	687b      	ldr	r3, [r7, #4]
 800d3f4:	681b      	ldr	r3, [r3, #0]
 800d3f6:	681a      	ldr	r2, [r3, #0]
 800d3f8:	687b      	ldr	r3, [r7, #4]
 800d3fa:	681b      	ldr	r3, [r3, #0]
 800d3fc:	f042 0204 	orr.w	r2, r2, #4
 800d400:	601a      	str	r2, [r3, #0]
 800d402:	e007      	b.n	800d414 <HAL_CAN_Init+0x1b8>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 800d404:	687b      	ldr	r3, [r7, #4]
 800d406:	681b      	ldr	r3, [r3, #0]
 800d408:	681a      	ldr	r2, [r3, #0]
 800d40a:	687b      	ldr	r3, [r7, #4]
 800d40c:	681b      	ldr	r3, [r3, #0]
 800d40e:	f022 0204 	bic.w	r2, r2, #4
 800d412:	601a      	str	r2, [r3, #0]
  }

  /* Set the bit timing register */
  WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |
 800d414:	687b      	ldr	r3, [r7, #4]
 800d416:	689a      	ldr	r2, [r3, #8]
 800d418:	687b      	ldr	r3, [r7, #4]
 800d41a:	68db      	ldr	r3, [r3, #12]
 800d41c:	431a      	orrs	r2, r3
 800d41e:	687b      	ldr	r3, [r7, #4]
 800d420:	691b      	ldr	r3, [r3, #16]
 800d422:	431a      	orrs	r2, r3
 800d424:	687b      	ldr	r3, [r7, #4]
 800d426:	695b      	ldr	r3, [r3, #20]
 800d428:	ea42 0103 	orr.w	r1, r2, r3
 800d42c:	687b      	ldr	r3, [r7, #4]
 800d42e:	685b      	ldr	r3, [r3, #4]
 800d430:	1e5a      	subs	r2, r3, #1
 800d432:	687b      	ldr	r3, [r7, #4]
 800d434:	681b      	ldr	r3, [r3, #0]
 800d436:	430a      	orrs	r2, r1
 800d438:	61da      	str	r2, [r3, #28]
                                            hcan->Init.TimeSeg1       |
                                            hcan->Init.TimeSeg2       |
                                            (hcan->Init.Prescaler - 1U)));

  /* Initialize the error code */
  hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 800d43a:	687b      	ldr	r3, [r7, #4]
 800d43c:	2200      	movs	r2, #0
 800d43e:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Initialize the CAN state */
  hcan->State = HAL_CAN_STATE_READY;
 800d440:	687b      	ldr	r3, [r7, #4]
 800d442:	2201      	movs	r2, #1
 800d444:	f883 2020 	strb.w	r2, [r3, #32]

  /* Return function status */
  return HAL_OK;
 800d448:	2300      	movs	r3, #0
}
 800d44a:	4618      	mov	r0, r3
 800d44c:	3710      	adds	r7, #16
 800d44e:	46bd      	mov	sp, r7
 800d450:	bd80      	pop	{r7, pc}

0800d452 <HAL_CAN_ConfigFilter>:
  * @param  sFilterConfig pointer to a CAN_FilterTypeDef structure that
  *         contains the filter configuration information.
  * @retval None
  */
HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, const CAN_FilterTypeDef *sFilterConfig)
{
 800d452:	b480      	push	{r7}
 800d454:	b087      	sub	sp, #28
 800d456:	af00      	add	r7, sp, #0
 800d458:	6078      	str	r0, [r7, #4]
 800d45a:	6039      	str	r1, [r7, #0]
  uint32_t filternbrbitpos;
  CAN_TypeDef *can_ip = hcan->Instance;
 800d45c:	687b      	ldr	r3, [r7, #4]
 800d45e:	681b      	ldr	r3, [r3, #0]
 800d460:	617b      	str	r3, [r7, #20]
  HAL_CAN_StateTypeDef state = hcan->State;
 800d462:	687b      	ldr	r3, [r7, #4]
 800d464:	f893 3020 	ldrb.w	r3, [r3, #32]
 800d468:	74fb      	strb	r3, [r7, #19]

  if ((state == HAL_CAN_STATE_READY) ||
 800d46a:	7cfb      	ldrb	r3, [r7, #19]
 800d46c:	2b01      	cmp	r3, #1
 800d46e:	d003      	beq.n	800d478 <HAL_CAN_ConfigFilter+0x26>
 800d470:	7cfb      	ldrb	r3, [r7, #19]
 800d472:	2b02      	cmp	r3, #2
 800d474:	f040 80aa 	bne.w	800d5cc <HAL_CAN_ConfigFilter+0x17a>
    /* Check the parameters */
    assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));
#endif

    /* Initialisation mode for the filter */
    SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
 800d478:	697b      	ldr	r3, [r7, #20]
 800d47a:	f8d3 3200 	ldr.w	r3, [r3, #512]	@ 0x200
 800d47e:	f043 0201 	orr.w	r2, r3, #1
 800d482:	697b      	ldr	r3, [r7, #20]
 800d484:	f8c3 2200 	str.w	r2, [r3, #512]	@ 0x200
    CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);
    SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);

#endif
    /* Convert filter number into bit position */
    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
 800d488:	683b      	ldr	r3, [r7, #0]
 800d48a:	695b      	ldr	r3, [r3, #20]
 800d48c:	f003 031f 	and.w	r3, r3, #31
 800d490:	2201      	movs	r2, #1
 800d492:	fa02 f303 	lsl.w	r3, r2, r3
 800d496:	60fb      	str	r3, [r7, #12]

    /* Filter Deactivation */
    CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
 800d498:	697b      	ldr	r3, [r7, #20]
 800d49a:	f8d3 221c 	ldr.w	r2, [r3, #540]	@ 0x21c
 800d49e:	68fb      	ldr	r3, [r7, #12]
 800d4a0:	43db      	mvns	r3, r3
 800d4a2:	401a      	ands	r2, r3
 800d4a4:	697b      	ldr	r3, [r7, #20]
 800d4a6:	f8c3 221c 	str.w	r2, [r3, #540]	@ 0x21c

    /* Filter Scale */
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 800d4aa:	683b      	ldr	r3, [r7, #0]
 800d4ac:	69db      	ldr	r3, [r3, #28]
 800d4ae:	2b00      	cmp	r3, #0
 800d4b0:	d123      	bne.n	800d4fa <HAL_CAN_ConfigFilter+0xa8>
    {
      /* 16-bit scale for the filter */
      CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
 800d4b2:	697b      	ldr	r3, [r7, #20]
 800d4b4:	f8d3 220c 	ldr.w	r2, [r3, #524]	@ 0x20c
 800d4b8:	68fb      	ldr	r3, [r7, #12]
 800d4ba:	43db      	mvns	r3, r3
 800d4bc:	401a      	ands	r2, r3
 800d4be:	697b      	ldr	r3, [r7, #20]
 800d4c0:	f8c3 220c 	str.w	r2, [r3, #524]	@ 0x20c

      /* First 16-bit identifier and First 16-bit mask */
      /* Or First 16-bit identifier and Second 16-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 800d4c4:	683b      	ldr	r3, [r7, #0]
 800d4c6:	68db      	ldr	r3, [r3, #12]
 800d4c8:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 800d4ca:	683b      	ldr	r3, [r7, #0]
 800d4cc:	685b      	ldr	r3, [r3, #4]
 800d4ce:	b29b      	uxth	r3, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 800d4d0:	683a      	ldr	r2, [r7, #0]
 800d4d2:	6952      	ldr	r2, [r2, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 800d4d4:	4319      	orrs	r1, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 800d4d6:	697b      	ldr	r3, [r7, #20]
 800d4d8:	3248      	adds	r2, #72	@ 0x48
 800d4da:	f843 1032 	str.w	r1, [r3, r2, lsl #3]

      /* Second 16-bit identifier and Second 16-bit mask */
      /* Or Third 16-bit identifier and Fourth 16-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 800d4de:	683b      	ldr	r3, [r7, #0]
 800d4e0:	689b      	ldr	r3, [r3, #8]
 800d4e2:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh);
 800d4e4:	683b      	ldr	r3, [r7, #0]
 800d4e6:	681b      	ldr	r3, [r3, #0]
 800d4e8:	b29a      	uxth	r2, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 800d4ea:	683b      	ldr	r3, [r7, #0]
 800d4ec:	695b      	ldr	r3, [r3, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 800d4ee:	430a      	orrs	r2, r1
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 800d4f0:	6979      	ldr	r1, [r7, #20]
 800d4f2:	3348      	adds	r3, #72	@ 0x48
 800d4f4:	00db      	lsls	r3, r3, #3
 800d4f6:	440b      	add	r3, r1
 800d4f8:	605a      	str	r2, [r3, #4]
    }

    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
 800d4fa:	683b      	ldr	r3, [r7, #0]
 800d4fc:	69db      	ldr	r3, [r3, #28]
 800d4fe:	2b01      	cmp	r3, #1
 800d500:	d122      	bne.n	800d548 <HAL_CAN_ConfigFilter+0xf6>
    {
      /* 32-bit scale for the filter */
      SET_BIT(can_ip->FS1R, filternbrbitpos);
 800d502:	697b      	ldr	r3, [r7, #20]
 800d504:	f8d3 220c 	ldr.w	r2, [r3, #524]	@ 0x20c
 800d508:	68fb      	ldr	r3, [r7, #12]
 800d50a:	431a      	orrs	r2, r3
 800d50c:	697b      	ldr	r3, [r7, #20]
 800d50e:	f8c3 220c 	str.w	r2, [r3, #524]	@ 0x20c

      /* 32-bit identifier or First 32-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 800d512:	683b      	ldr	r3, [r7, #0]
 800d514:	681b      	ldr	r3, [r3, #0]
 800d516:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 800d518:	683b      	ldr	r3, [r7, #0]
 800d51a:	685b      	ldr	r3, [r3, #4]
 800d51c:	b29b      	uxth	r3, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 800d51e:	683a      	ldr	r2, [r7, #0]
 800d520:	6952      	ldr	r2, [r2, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 800d522:	4319      	orrs	r1, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 800d524:	697b      	ldr	r3, [r7, #20]
 800d526:	3248      	adds	r2, #72	@ 0x48
 800d528:	f843 1032 	str.w	r1, [r3, r2, lsl #3]

      /* 32-bit mask or Second 32-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 800d52c:	683b      	ldr	r3, [r7, #0]
 800d52e:	689b      	ldr	r3, [r3, #8]
 800d530:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);
 800d532:	683b      	ldr	r3, [r7, #0]
 800d534:	68db      	ldr	r3, [r3, #12]
 800d536:	b29a      	uxth	r2, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 800d538:	683b      	ldr	r3, [r7, #0]
 800d53a:	695b      	ldr	r3, [r3, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 800d53c:	430a      	orrs	r2, r1
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 800d53e:	6979      	ldr	r1, [r7, #20]
 800d540:	3348      	adds	r3, #72	@ 0x48
 800d542:	00db      	lsls	r3, r3, #3
 800d544:	440b      	add	r3, r1
 800d546:	605a      	str	r2, [r3, #4]
    }

    /* Filter Mode */
    if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 800d548:	683b      	ldr	r3, [r7, #0]
 800d54a:	699b      	ldr	r3, [r3, #24]
 800d54c:	2b00      	cmp	r3, #0
 800d54e:	d109      	bne.n	800d564 <HAL_CAN_ConfigFilter+0x112>
    {
      /* Id/Mask mode for the filter*/
      CLEAR_BIT(can_ip->FM1R, filternbrbitpos);
 800d550:	697b      	ldr	r3, [r7, #20]
 800d552:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 800d556:	68fb      	ldr	r3, [r7, #12]
 800d558:	43db      	mvns	r3, r3
 800d55a:	401a      	ands	r2, r3
 800d55c:	697b      	ldr	r3, [r7, #20]
 800d55e:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
 800d562:	e007      	b.n	800d574 <HAL_CAN_ConfigFilter+0x122>
    }
    else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    {
      /* Identifier list mode for the filter*/
      SET_BIT(can_ip->FM1R, filternbrbitpos);
 800d564:	697b      	ldr	r3, [r7, #20]
 800d566:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 800d56a:	68fb      	ldr	r3, [r7, #12]
 800d56c:	431a      	orrs	r2, r3
 800d56e:	697b      	ldr	r3, [r7, #20]
 800d570:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
    }

    /* Filter FIFO assignment */
    if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 800d574:	683b      	ldr	r3, [r7, #0]
 800d576:	691b      	ldr	r3, [r3, #16]
 800d578:	2b00      	cmp	r3, #0
 800d57a:	d109      	bne.n	800d590 <HAL_CAN_ConfigFilter+0x13e>
    {
      /* FIFO 0 assignation for the filter */
      CLEAR_BIT(can_ip->FFA1R, filternbrbitpos);
 800d57c:	697b      	ldr	r3, [r7, #20]
 800d57e:	f8d3 2214 	ldr.w	r2, [r3, #532]	@ 0x214
 800d582:	68fb      	ldr	r3, [r7, #12]
 800d584:	43db      	mvns	r3, r3
 800d586:	401a      	ands	r2, r3
 800d588:	697b      	ldr	r3, [r7, #20]
 800d58a:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214
 800d58e:	e007      	b.n	800d5a0 <HAL_CAN_ConfigFilter+0x14e>
    }
    else
    {
      /* FIFO 1 assignation for the filter */
      SET_BIT(can_ip->FFA1R, filternbrbitpos);
 800d590:	697b      	ldr	r3, [r7, #20]
 800d592:	f8d3 2214 	ldr.w	r2, [r3, #532]	@ 0x214
 800d596:	68fb      	ldr	r3, [r7, #12]
 800d598:	431a      	orrs	r2, r3
 800d59a:	697b      	ldr	r3, [r7, #20]
 800d59c:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214
    }

    /* Filter activation */
    if (sFilterConfig->FilterActivation == CAN_FILTER_ENABLE)
 800d5a0:	683b      	ldr	r3, [r7, #0]
 800d5a2:	6a1b      	ldr	r3, [r3, #32]
 800d5a4:	2b01      	cmp	r3, #1
 800d5a6:	d107      	bne.n	800d5b8 <HAL_CAN_ConfigFilter+0x166>
    {
      SET_BIT(can_ip->FA1R, filternbrbitpos);
 800d5a8:	697b      	ldr	r3, [r7, #20]
 800d5aa:	f8d3 221c 	ldr.w	r2, [r3, #540]	@ 0x21c
 800d5ae:	68fb      	ldr	r3, [r7, #12]
 800d5b0:	431a      	orrs	r2, r3
 800d5b2:	697b      	ldr	r3, [r7, #20]
 800d5b4:	f8c3 221c 	str.w	r2, [r3, #540]	@ 0x21c
    }

    /* Leave the initialisation mode for the filter */
    CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
 800d5b8:	697b      	ldr	r3, [r7, #20]
 800d5ba:	f8d3 3200 	ldr.w	r3, [r3, #512]	@ 0x200
 800d5be:	f023 0201 	bic.w	r2, r3, #1
 800d5c2:	697b      	ldr	r3, [r7, #20]
 800d5c4:	f8c3 2200 	str.w	r2, [r3, #512]	@ 0x200

    /* Return function status */
    return HAL_OK;
 800d5c8:	2300      	movs	r3, #0
 800d5ca:	e006      	b.n	800d5da <HAL_CAN_ConfigFilter+0x188>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 800d5cc:	687b      	ldr	r3, [r7, #4]
 800d5ce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d5d0:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
 800d5d4:	687b      	ldr	r3, [r7, #4]
 800d5d6:	625a      	str	r2, [r3, #36]	@ 0x24

    return HAL_ERROR;
 800d5d8:	2301      	movs	r3, #1
  }
}
 800d5da:	4618      	mov	r0, r3
 800d5dc:	371c      	adds	r7, #28
 800d5de:	46bd      	mov	sp, r7
 800d5e0:	bc80      	pop	{r7}
 800d5e2:	4770      	bx	lr

0800d5e4 <HAL_CAN_Start>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)
{
 800d5e4:	b580      	push	{r7, lr}
 800d5e6:	b084      	sub	sp, #16
 800d5e8:	af00      	add	r7, sp, #0
 800d5ea:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  if (hcan->State == HAL_CAN_STATE_READY)
 800d5ec:	687b      	ldr	r3, [r7, #4]
 800d5ee:	f893 3020 	ldrb.w	r3, [r3, #32]
 800d5f2:	b2db      	uxtb	r3, r3
 800d5f4:	2b01      	cmp	r3, #1
 800d5f6:	d12e      	bne.n	800d656 <HAL_CAN_Start+0x72>
  {
    /* Change CAN peripheral state */
    hcan->State = HAL_CAN_STATE_LISTENING;
 800d5f8:	687b      	ldr	r3, [r7, #4]
 800d5fa:	2202      	movs	r2, #2
 800d5fc:	f883 2020 	strb.w	r2, [r3, #32]

    /* Request leave initialisation */
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 800d600:	687b      	ldr	r3, [r7, #4]
 800d602:	681b      	ldr	r3, [r3, #0]
 800d604:	681a      	ldr	r2, [r3, #0]
 800d606:	687b      	ldr	r3, [r7, #4]
 800d608:	681b      	ldr	r3, [r3, #0]
 800d60a:	f022 0201 	bic.w	r2, r2, #1
 800d60e:	601a      	str	r2, [r3, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 800d610:	f7ff fe1a 	bl	800d248 <HAL_GetTick>
 800d614:	60f8      	str	r0, [r7, #12]

    /* Wait the acknowledge */
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
 800d616:	e012      	b.n	800d63e <HAL_CAN_Start+0x5a>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 800d618:	f7ff fe16 	bl	800d248 <HAL_GetTick>
 800d61c:	4602      	mov	r2, r0
 800d61e:	68fb      	ldr	r3, [r7, #12]
 800d620:	1ad3      	subs	r3, r2, r3
 800d622:	2b0a      	cmp	r3, #10
 800d624:	d90b      	bls.n	800d63e <HAL_CAN_Start+0x5a>
      {
        /* Update error code */
        hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 800d626:	687b      	ldr	r3, [r7, #4]
 800d628:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d62a:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
 800d62e:	687b      	ldr	r3, [r7, #4]
 800d630:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Change CAN state */
        hcan->State = HAL_CAN_STATE_ERROR;
 800d632:	687b      	ldr	r3, [r7, #4]
 800d634:	2205      	movs	r2, #5
 800d636:	f883 2020 	strb.w	r2, [r3, #32]

        return HAL_ERROR;
 800d63a:	2301      	movs	r3, #1
 800d63c:	e012      	b.n	800d664 <HAL_CAN_Start+0x80>
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
 800d63e:	687b      	ldr	r3, [r7, #4]
 800d640:	681b      	ldr	r3, [r3, #0]
 800d642:	685b      	ldr	r3, [r3, #4]
 800d644:	f003 0301 	and.w	r3, r3, #1
 800d648:	2b00      	cmp	r3, #0
 800d64a:	d1e5      	bne.n	800d618 <HAL_CAN_Start+0x34>
      }
    }

    /* Reset the CAN ErrorCode */
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 800d64c:	687b      	ldr	r3, [r7, #4]
 800d64e:	2200      	movs	r2, #0
 800d650:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Return function status */
    return HAL_OK;
 800d652:	2300      	movs	r3, #0
 800d654:	e006      	b.n	800d664 <HAL_CAN_Start+0x80>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;
 800d656:	687b      	ldr	r3, [r7, #4]
 800d658:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d65a:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
 800d65e:	687b      	ldr	r3, [r7, #4]
 800d660:	625a      	str	r2, [r3, #36]	@ 0x24

    return HAL_ERROR;
 800d662:	2301      	movs	r3, #1
  }
}
 800d664:	4618      	mov	r0, r3
 800d666:	3710      	adds	r7, #16
 800d668:	46bd      	mov	sp, r7
 800d66a:	bd80      	pop	{r7, pc}

0800d66c <HAL_CAN_GetRxMessage>:
  * @param  aData array where the payload of the Rx frame will be stored.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo,
                                       CAN_RxHeaderTypeDef *pHeader, uint8_t aData[])
{
 800d66c:	b480      	push	{r7}
 800d66e:	b087      	sub	sp, #28
 800d670:	af00      	add	r7, sp, #0
 800d672:	60f8      	str	r0, [r7, #12]
 800d674:	60b9      	str	r1, [r7, #8]
 800d676:	607a      	str	r2, [r7, #4]
 800d678:	603b      	str	r3, [r7, #0]
	  HAL_CAN_StateTypeDef state;

		    // Poll until a message is available
		    while (1) {
		        state = hcan->State;
 800d67a:	68fb      	ldr	r3, [r7, #12]
 800d67c:	f893 3020 	ldrb.w	r3, [r3, #32]
 800d680:	75fb      	strb	r3, [r7, #23]

		        // Check the CAN state
		        if ((state == HAL_CAN_STATE_READY) || (state == HAL_CAN_STATE_LISTENING)) {
 800d682:	7dfb      	ldrb	r3, [r7, #23]
 800d684:	2b01      	cmp	r3, #1
 800d686:	d002      	beq.n	800d68e <HAL_CAN_GetRxMessage+0x22>
 800d688:	7dfb      	ldrb	r3, [r7, #23]
 800d68a:	2b02      	cmp	r3, #2
 800d68c:	d1f5      	bne.n	800d67a <HAL_CAN_GetRxMessage+0xe>
		            // Check the Rx FIFO
		            if (RxFifo == CAN_RX_FIFO0) {
 800d68e:	68bb      	ldr	r3, [r7, #8]
 800d690:	2b00      	cmp	r3, #0
 800d692:	d107      	bne.n	800d6a4 <HAL_CAN_GetRxMessage+0x38>
		                // Check that the Rx FIFO 0 is not empty
		                if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) != 0U) {
 800d694:	68fb      	ldr	r3, [r7, #12]
 800d696:	681b      	ldr	r3, [r3, #0]
 800d698:	68db      	ldr	r3, [r3, #12]
 800d69a:	f003 0303 	and.w	r3, r3, #3
 800d69e:	2b00      	cmp	r3, #0
 800d6a0:	d0eb      	beq.n	800d67a <HAL_CAN_GetRxMessage+0xe>
		                    break;  // Exit the loop if a message is available
 800d6a2:	e008      	b.n	800d6b6 <HAL_CAN_GetRxMessage+0x4a>
		                }
		            } else {
		                // Check that the Rx FIFO 1 is not empty
		                if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) != 0U) {
 800d6a4:	68fb      	ldr	r3, [r7, #12]
 800d6a6:	681b      	ldr	r3, [r3, #0]
 800d6a8:	691b      	ldr	r3, [r3, #16]
 800d6aa:	f003 0303 	and.w	r3, r3, #3
 800d6ae:	2b00      	cmp	r3, #0
 800d6b0:	d100      	bne.n	800d6b4 <HAL_CAN_GetRxMessage+0x48>
		        state = hcan->State;
 800d6b2:	e7e2      	b.n	800d67a <HAL_CAN_GetRxMessage+0xe>
		                    break;  // Exit the loop if a message is available
 800d6b4:	bf00      	nop
		            }
		        }
		    }

		    // Get the header
		    pHeader->IDE = CAN_RI0R_IDE & hcan->Instance->sFIFOMailBox[RxFifo].RIR;
 800d6b6:	68fb      	ldr	r3, [r7, #12]
 800d6b8:	681a      	ldr	r2, [r3, #0]
 800d6ba:	68bb      	ldr	r3, [r7, #8]
 800d6bc:	331b      	adds	r3, #27
 800d6be:	011b      	lsls	r3, r3, #4
 800d6c0:	4413      	add	r3, r2
 800d6c2:	681b      	ldr	r3, [r3, #0]
 800d6c4:	f003 0204 	and.w	r2, r3, #4
 800d6c8:	687b      	ldr	r3, [r7, #4]
 800d6ca:	609a      	str	r2, [r3, #8]
		    if (pHeader->IDE == CAN_ID_STD) {
 800d6cc:	687b      	ldr	r3, [r7, #4]
 800d6ce:	689b      	ldr	r3, [r3, #8]
 800d6d0:	2b00      	cmp	r3, #0
 800d6d2:	d10c      	bne.n	800d6ee <HAL_CAN_GetRxMessage+0x82>
		        pHeader->StdId = (CAN_RI0R_STID & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_TI0R_STID_Pos;
 800d6d4:	68fb      	ldr	r3, [r7, #12]
 800d6d6:	681a      	ldr	r2, [r3, #0]
 800d6d8:	68bb      	ldr	r3, [r7, #8]
 800d6da:	331b      	adds	r3, #27
 800d6dc:	011b      	lsls	r3, r3, #4
 800d6de:	4413      	add	r3, r2
 800d6e0:	681b      	ldr	r3, [r3, #0]
 800d6e2:	0d5b      	lsrs	r3, r3, #21
 800d6e4:	f3c3 020a 	ubfx	r2, r3, #0, #11
 800d6e8:	687b      	ldr	r3, [r7, #4]
 800d6ea:	601a      	str	r2, [r3, #0]
 800d6ec:	e00b      	b.n	800d706 <HAL_CAN_GetRxMessage+0x9a>
		    } else {
		        pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) &
		                          hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_EXID_Pos;
 800d6ee:	68fb      	ldr	r3, [r7, #12]
 800d6f0:	681a      	ldr	r2, [r3, #0]
 800d6f2:	68bb      	ldr	r3, [r7, #8]
 800d6f4:	331b      	adds	r3, #27
 800d6f6:	011b      	lsls	r3, r3, #4
 800d6f8:	4413      	add	r3, r2
 800d6fa:	681b      	ldr	r3, [r3, #0]
 800d6fc:	08db      	lsrs	r3, r3, #3
 800d6fe:	f023 4260 	bic.w	r2, r3, #3758096384	@ 0xe0000000
		        pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) &
 800d702:	687b      	ldr	r3, [r7, #4]
 800d704:	605a      	str	r2, [r3, #4]
		    }
		    pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR);
 800d706:	68fb      	ldr	r3, [r7, #12]
 800d708:	681a      	ldr	r2, [r3, #0]
 800d70a:	68bb      	ldr	r3, [r7, #8]
 800d70c:	331b      	adds	r3, #27
 800d70e:	011b      	lsls	r3, r3, #4
 800d710:	4413      	add	r3, r2
 800d712:	681b      	ldr	r3, [r3, #0]
 800d714:	f003 0202 	and.w	r2, r3, #2
 800d718:	687b      	ldr	r3, [r7, #4]
 800d71a:	60da      	str	r2, [r3, #12]
		    if (((CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos) >= 8U) {
 800d71c:	68fb      	ldr	r3, [r7, #12]
 800d71e:	681a      	ldr	r2, [r3, #0]
 800d720:	68bb      	ldr	r3, [r7, #8]
 800d722:	331b      	adds	r3, #27
 800d724:	011b      	lsls	r3, r3, #4
 800d726:	4413      	add	r3, r2
 800d728:	3304      	adds	r3, #4
 800d72a:	681b      	ldr	r3, [r3, #0]
 800d72c:	f003 0308 	and.w	r3, r3, #8
 800d730:	2b00      	cmp	r3, #0
 800d732:	d003      	beq.n	800d73c <HAL_CAN_GetRxMessage+0xd0>
		        /* Truncate DLC to 8 if received field is over range */
		        pHeader->DLC = 8U;
 800d734:	687b      	ldr	r3, [r7, #4]
 800d736:	2208      	movs	r2, #8
 800d738:	611a      	str	r2, [r3, #16]
 800d73a:	e00b      	b.n	800d754 <HAL_CAN_GetRxMessage+0xe8>
		    } else {
		        pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
 800d73c:	68fb      	ldr	r3, [r7, #12]
 800d73e:	681a      	ldr	r2, [r3, #0]
 800d740:	68bb      	ldr	r3, [r7, #8]
 800d742:	331b      	adds	r3, #27
 800d744:	011b      	lsls	r3, r3, #4
 800d746:	4413      	add	r3, r2
 800d748:	3304      	adds	r3, #4
 800d74a:	681b      	ldr	r3, [r3, #0]
 800d74c:	f003 020f 	and.w	r2, r3, #15
 800d750:	687b      	ldr	r3, [r7, #4]
 800d752:	611a      	str	r2, [r3, #16]
		    }
		    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 800d754:	68fb      	ldr	r3, [r7, #12]
 800d756:	681a      	ldr	r2, [r3, #0]
 800d758:	68bb      	ldr	r3, [r7, #8]
 800d75a:	331b      	adds	r3, #27
 800d75c:	011b      	lsls	r3, r3, #4
 800d75e:	4413      	add	r3, r2
 800d760:	3304      	adds	r3, #4
 800d762:	681b      	ldr	r3, [r3, #0]
 800d764:	0a1b      	lsrs	r3, r3, #8
 800d766:	b2da      	uxtb	r2, r3
 800d768:	687b      	ldr	r3, [r7, #4]
 800d76a:	619a      	str	r2, [r3, #24]
		    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 800d76c:	68fb      	ldr	r3, [r7, #12]
 800d76e:	681a      	ldr	r2, [r3, #0]
 800d770:	68bb      	ldr	r3, [r7, #8]
 800d772:	331b      	adds	r3, #27
 800d774:	011b      	lsls	r3, r3, #4
 800d776:	4413      	add	r3, r2
 800d778:	3304      	adds	r3, #4
 800d77a:	681b      	ldr	r3, [r3, #0]
 800d77c:	0c1b      	lsrs	r3, r3, #16
 800d77e:	b29a      	uxth	r2, r3
 800d780:	687b      	ldr	r3, [r7, #4]
 800d782:	615a      	str	r2, [r3, #20]

		    // Get the data
		    pHeader->data[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
 800d784:	68fb      	ldr	r3, [r7, #12]
 800d786:	681a      	ldr	r2, [r3, #0]
 800d788:	68bb      	ldr	r3, [r7, #8]
 800d78a:	011b      	lsls	r3, r3, #4
 800d78c:	4413      	add	r3, r2
 800d78e:	f503 73dc 	add.w	r3, r3, #440	@ 0x1b8
 800d792:	681b      	ldr	r3, [r3, #0]
 800d794:	b2da      	uxtb	r2, r3
 800d796:	687b      	ldr	r3, [r7, #4]
 800d798:	771a      	strb	r2, [r3, #28]
		    pHeader->data[1] = (uint8_t)((CAN_RDL0R_DATA1 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA1_Pos);
 800d79a:	68fb      	ldr	r3, [r7, #12]
 800d79c:	681a      	ldr	r2, [r3, #0]
 800d79e:	68bb      	ldr	r3, [r7, #8]
 800d7a0:	011b      	lsls	r3, r3, #4
 800d7a2:	4413      	add	r3, r2
 800d7a4:	f503 73dc 	add.w	r3, r3, #440	@ 0x1b8
 800d7a8:	681b      	ldr	r3, [r3, #0]
 800d7aa:	0a1b      	lsrs	r3, r3, #8
 800d7ac:	b2da      	uxtb	r2, r3
 800d7ae:	687b      	ldr	r3, [r7, #4]
 800d7b0:	775a      	strb	r2, [r3, #29]
		    pHeader->data[2] = (uint8_t)((CAN_RDL0R_DATA2 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA2_Pos);
 800d7b2:	68fb      	ldr	r3, [r7, #12]
 800d7b4:	681a      	ldr	r2, [r3, #0]
 800d7b6:	68bb      	ldr	r3, [r7, #8]
 800d7b8:	011b      	lsls	r3, r3, #4
 800d7ba:	4413      	add	r3, r2
 800d7bc:	f503 73dc 	add.w	r3, r3, #440	@ 0x1b8
 800d7c0:	681b      	ldr	r3, [r3, #0]
 800d7c2:	0c1b      	lsrs	r3, r3, #16
 800d7c4:	b2da      	uxtb	r2, r3
 800d7c6:	687b      	ldr	r3, [r7, #4]
 800d7c8:	779a      	strb	r2, [r3, #30]
		    pHeader->data[3] = (uint8_t)((CAN_RDL0R_DATA3 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA3_Pos);
 800d7ca:	68fb      	ldr	r3, [r7, #12]
 800d7cc:	681a      	ldr	r2, [r3, #0]
 800d7ce:	68bb      	ldr	r3, [r7, #8]
 800d7d0:	011b      	lsls	r3, r3, #4
 800d7d2:	4413      	add	r3, r2
 800d7d4:	f503 73dc 	add.w	r3, r3, #440	@ 0x1b8
 800d7d8:	681b      	ldr	r3, [r3, #0]
 800d7da:	0e1b      	lsrs	r3, r3, #24
 800d7dc:	b2da      	uxtb	r2, r3
 800d7de:	687b      	ldr	r3, [r7, #4]
 800d7e0:	77da      	strb	r2, [r3, #31]
		    pHeader->data[4] = (uint8_t)((CAN_RDH0R_DATA4 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA4_Pos);
 800d7e2:	68fb      	ldr	r3, [r7, #12]
 800d7e4:	681a      	ldr	r2, [r3, #0]
 800d7e6:	68bb      	ldr	r3, [r7, #8]
 800d7e8:	011b      	lsls	r3, r3, #4
 800d7ea:	4413      	add	r3, r2
 800d7ec:	f503 73de 	add.w	r3, r3, #444	@ 0x1bc
 800d7f0:	681b      	ldr	r3, [r3, #0]
 800d7f2:	b2da      	uxtb	r2, r3
 800d7f4:	687b      	ldr	r3, [r7, #4]
 800d7f6:	f883 2020 	strb.w	r2, [r3, #32]
		    pHeader->data[5] = (uint8_t)((CAN_RDH0R_DATA5 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA5_Pos);
 800d7fa:	68fb      	ldr	r3, [r7, #12]
 800d7fc:	681a      	ldr	r2, [r3, #0]
 800d7fe:	68bb      	ldr	r3, [r7, #8]
 800d800:	011b      	lsls	r3, r3, #4
 800d802:	4413      	add	r3, r2
 800d804:	f503 73de 	add.w	r3, r3, #444	@ 0x1bc
 800d808:	681b      	ldr	r3, [r3, #0]
 800d80a:	0a1b      	lsrs	r3, r3, #8
 800d80c:	b2da      	uxtb	r2, r3
 800d80e:	687b      	ldr	r3, [r7, #4]
 800d810:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
		    pHeader->data[6] = (uint8_t)((CAN_RDH0R_DATA6 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA6_Pos);
 800d814:	68fb      	ldr	r3, [r7, #12]
 800d816:	681a      	ldr	r2, [r3, #0]
 800d818:	68bb      	ldr	r3, [r7, #8]
 800d81a:	011b      	lsls	r3, r3, #4
 800d81c:	4413      	add	r3, r2
 800d81e:	f503 73de 	add.w	r3, r3, #444	@ 0x1bc
 800d822:	681b      	ldr	r3, [r3, #0]
 800d824:	0c1b      	lsrs	r3, r3, #16
 800d826:	b2da      	uxtb	r2, r3
 800d828:	687b      	ldr	r3, [r7, #4]
 800d82a:	f883 2022 	strb.w	r2, [r3, #34]	@ 0x22
		    pHeader->data[7] = (uint8_t)((CAN_RDH0R_DATA7 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA7_Pos);
 800d82e:	68fb      	ldr	r3, [r7, #12]
 800d830:	681a      	ldr	r2, [r3, #0]
 800d832:	68bb      	ldr	r3, [r7, #8]
 800d834:	011b      	lsls	r3, r3, #4
 800d836:	4413      	add	r3, r2
 800d838:	f503 73de 	add.w	r3, r3, #444	@ 0x1bc
 800d83c:	681b      	ldr	r3, [r3, #0]
 800d83e:	0e1b      	lsrs	r3, r3, #24
 800d840:	b2da      	uxtb	r2, r3
 800d842:	687b      	ldr	r3, [r7, #4]
 800d844:	f883 2023 	strb.w	r2, [r3, #35]	@ 0x23

		    // Release the FIFO
		    if (RxFifo == CAN_RX_FIFO0) {
 800d848:	68bb      	ldr	r3, [r7, #8]
 800d84a:	2b00      	cmp	r3, #0
 800d84c:	d108      	bne.n	800d860 <HAL_CAN_GetRxMessage+0x1f4>
		        // Release RX FIFO 0
		        SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
 800d84e:	68fb      	ldr	r3, [r7, #12]
 800d850:	681b      	ldr	r3, [r3, #0]
 800d852:	68da      	ldr	r2, [r3, #12]
 800d854:	68fb      	ldr	r3, [r7, #12]
 800d856:	681b      	ldr	r3, [r3, #0]
 800d858:	f042 0220 	orr.w	r2, r2, #32
 800d85c:	60da      	str	r2, [r3, #12]
 800d85e:	e007      	b.n	800d870 <HAL_CAN_GetRxMessage+0x204>
		    } else {
		        // Release RX FIFO 1
		        SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);
 800d860:	68fb      	ldr	r3, [r7, #12]
 800d862:	681b      	ldr	r3, [r3, #0]
 800d864:	691a      	ldr	r2, [r3, #16]
 800d866:	68fb      	ldr	r3, [r7, #12]
 800d868:	681b      	ldr	r3, [r3, #0]
 800d86a:	f042 0220 	orr.w	r2, r2, #32
 800d86e:	611a      	str	r2, [r3, #16]
		    }

		    // Return function status
		    return HAL_OK;
 800d870:	2300      	movs	r3, #0
}
 800d872:	4618      	mov	r0, r3
 800d874:	371c      	adds	r7, #28
 800d876:	46bd      	mov	sp, r7
 800d878:	bc80      	pop	{r7}
 800d87a:	4770      	bx	lr

0800d87c <HAL_CAN_ActivateNotification>:
  * @param  ActiveITs indicates which interrupts will be enabled.
  *         This parameter can be any combination of @arg CAN_Interrupts.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_ActivateNotification(CAN_HandleTypeDef *hcan, uint32_t ActiveITs)
{
 800d87c:	b480      	push	{r7}
 800d87e:	b085      	sub	sp, #20
 800d880:	af00      	add	r7, sp, #0
 800d882:	6078      	str	r0, [r7, #4]
 800d884:	6039      	str	r1, [r7, #0]
  HAL_CAN_StateTypeDef state = hcan->State;
 800d886:	687b      	ldr	r3, [r7, #4]
 800d888:	f893 3020 	ldrb.w	r3, [r3, #32]
 800d88c:	73fb      	strb	r3, [r7, #15]

  /* Check function parameters */
  assert_param(IS_CAN_IT(ActiveITs));

  if ((state == HAL_CAN_STATE_READY) ||
 800d88e:	7bfb      	ldrb	r3, [r7, #15]
 800d890:	2b01      	cmp	r3, #1
 800d892:	d002      	beq.n	800d89a <HAL_CAN_ActivateNotification+0x1e>
 800d894:	7bfb      	ldrb	r3, [r7, #15]
 800d896:	2b02      	cmp	r3, #2
 800d898:	d109      	bne.n	800d8ae <HAL_CAN_ActivateNotification+0x32>
      (state == HAL_CAN_STATE_LISTENING))
  {
    /* Enable the selected interrupts */
    __HAL_CAN_ENABLE_IT(hcan, ActiveITs);
 800d89a:	687b      	ldr	r3, [r7, #4]
 800d89c:	681b      	ldr	r3, [r3, #0]
 800d89e:	6959      	ldr	r1, [r3, #20]
 800d8a0:	687b      	ldr	r3, [r7, #4]
 800d8a2:	681b      	ldr	r3, [r3, #0]
 800d8a4:	683a      	ldr	r2, [r7, #0]
 800d8a6:	430a      	orrs	r2, r1
 800d8a8:	615a      	str	r2, [r3, #20]

    /* Return function status */
    return HAL_OK;
 800d8aa:	2300      	movs	r3, #0
 800d8ac:	e006      	b.n	800d8bc <HAL_CAN_ActivateNotification+0x40>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 800d8ae:	687b      	ldr	r3, [r7, #4]
 800d8b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d8b2:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
 800d8b6:	687b      	ldr	r3, [r7, #4]
 800d8b8:	625a      	str	r2, [r3, #36]	@ 0x24

    return HAL_ERROR;
 800d8ba:	2301      	movs	r3, #1
  }
}
 800d8bc:	4618      	mov	r0, r3
 800d8be:	3714      	adds	r7, #20
 800d8c0:	46bd      	mov	sp, r7
 800d8c2:	bc80      	pop	{r7}
 800d8c4:	4770      	bx	lr

0800d8c6 <HAL_CAN_IRQHandler>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
void HAL_CAN_IRQHandler(CAN_HandleTypeDef *hcan)
{
 800d8c6:	b580      	push	{r7, lr}
 800d8c8:	b08a      	sub	sp, #40	@ 0x28
 800d8ca:	af00      	add	r7, sp, #0
 800d8cc:	6078      	str	r0, [r7, #4]
  uint32_t errorcode = HAL_CAN_ERROR_NONE;
 800d8ce:	2300      	movs	r3, #0
 800d8d0:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t interrupts = READ_REG(hcan->Instance->IER);
 800d8d2:	687b      	ldr	r3, [r7, #4]
 800d8d4:	681b      	ldr	r3, [r3, #0]
 800d8d6:	695b      	ldr	r3, [r3, #20]
 800d8d8:	623b      	str	r3, [r7, #32]
  uint32_t msrflags = READ_REG(hcan->Instance->MSR);
 800d8da:	687b      	ldr	r3, [r7, #4]
 800d8dc:	681b      	ldr	r3, [r3, #0]
 800d8de:	685b      	ldr	r3, [r3, #4]
 800d8e0:	61fb      	str	r3, [r7, #28]
  uint32_t tsrflags = READ_REG(hcan->Instance->TSR);
 800d8e2:	687b      	ldr	r3, [r7, #4]
 800d8e4:	681b      	ldr	r3, [r3, #0]
 800d8e6:	689b      	ldr	r3, [r3, #8]
 800d8e8:	61bb      	str	r3, [r7, #24]
  uint32_t rf0rflags = READ_REG(hcan->Instance->RF0R);
 800d8ea:	687b      	ldr	r3, [r7, #4]
 800d8ec:	681b      	ldr	r3, [r3, #0]
 800d8ee:	68db      	ldr	r3, [r3, #12]
 800d8f0:	617b      	str	r3, [r7, #20]
  uint32_t rf1rflags = READ_REG(hcan->Instance->RF1R);
 800d8f2:	687b      	ldr	r3, [r7, #4]
 800d8f4:	681b      	ldr	r3, [r3, #0]
 800d8f6:	691b      	ldr	r3, [r3, #16]
 800d8f8:	613b      	str	r3, [r7, #16]
  uint32_t esrflags = READ_REG(hcan->Instance->ESR);
 800d8fa:	687b      	ldr	r3, [r7, #4]
 800d8fc:	681b      	ldr	r3, [r3, #0]
 800d8fe:	699b      	ldr	r3, [r3, #24]
 800d900:	60fb      	str	r3, [r7, #12]

  /* Transmit Mailbox empty interrupt management *****************************/
  if ((interrupts & CAN_IT_TX_MAILBOX_EMPTY) != 0U)
 800d902:	6a3b      	ldr	r3, [r7, #32]
 800d904:	f003 0301 	and.w	r3, r3, #1
 800d908:	2b00      	cmp	r3, #0
 800d90a:	d07c      	beq.n	800da06 <HAL_CAN_IRQHandler+0x140>
  {
    /* Transmit Mailbox 0 management *****************************************/
    if ((tsrflags & CAN_TSR_RQCP0) != 0U)
 800d90c:	69bb      	ldr	r3, [r7, #24]
 800d90e:	f003 0301 	and.w	r3, r3, #1
 800d912:	2b00      	cmp	r3, #0
 800d914:	d023      	beq.n	800d95e <HAL_CAN_IRQHandler+0x98>
    {
      /* Clear the Transmission Complete flag (and TXOK0,ALST0,TERR0 bits) */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP0);
 800d916:	687b      	ldr	r3, [r7, #4]
 800d918:	681b      	ldr	r3, [r3, #0]
 800d91a:	2201      	movs	r2, #1
 800d91c:	609a      	str	r2, [r3, #8]

      if ((tsrflags & CAN_TSR_TXOK0) != 0U)
 800d91e:	69bb      	ldr	r3, [r7, #24]
 800d920:	f003 0302 	and.w	r3, r3, #2
 800d924:	2b00      	cmp	r3, #0
 800d926:	d003      	beq.n	800d930 <HAL_CAN_IRQHandler+0x6a>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
        /* Call registered callback*/
        hcan->TxMailbox0CompleteCallback(hcan);
#else
        /* Call weak (surcharged) callback */
        HAL_CAN_TxMailbox0CompleteCallback(hcan);
 800d928:	6878      	ldr	r0, [r7, #4]
 800d92a:	f000 f983 	bl	800dc34 <HAL_CAN_TxMailbox0CompleteCallback>
 800d92e:	e016      	b.n	800d95e <HAL_CAN_IRQHandler+0x98>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
      }
      else
      {
        if ((tsrflags & CAN_TSR_ALST0) != 0U)
 800d930:	69bb      	ldr	r3, [r7, #24]
 800d932:	f003 0304 	and.w	r3, r3, #4
 800d936:	2b00      	cmp	r3, #0
 800d938:	d004      	beq.n	800d944 <HAL_CAN_IRQHandler+0x7e>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_ALST0;
 800d93a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d93c:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 800d940:	627b      	str	r3, [r7, #36]	@ 0x24
 800d942:	e00c      	b.n	800d95e <HAL_CAN_IRQHandler+0x98>
        }
        else if ((tsrflags & CAN_TSR_TERR0) != 0U)
 800d944:	69bb      	ldr	r3, [r7, #24]
 800d946:	f003 0308 	and.w	r3, r3, #8
 800d94a:	2b00      	cmp	r3, #0
 800d94c:	d004      	beq.n	800d958 <HAL_CAN_IRQHandler+0x92>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_TERR0;
 800d94e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d950:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 800d954:	627b      	str	r3, [r7, #36]	@ 0x24
 800d956:	e002      	b.n	800d95e <HAL_CAN_IRQHandler+0x98>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
          /* Call registered callback*/
          hcan->TxMailbox0AbortCallback(hcan);
#else
          /* Call weak (surcharged) callback */
          HAL_CAN_TxMailbox0AbortCallback(hcan);
 800d958:	6878      	ldr	r0, [r7, #4]
 800d95a:	f000 f986 	bl	800dc6a <HAL_CAN_TxMailbox0AbortCallback>
        }
      }
    }

    /* Transmit Mailbox 1 management *****************************************/
    if ((tsrflags & CAN_TSR_RQCP1) != 0U)
 800d95e:	69bb      	ldr	r3, [r7, #24]
 800d960:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800d964:	2b00      	cmp	r3, #0
 800d966:	d024      	beq.n	800d9b2 <HAL_CAN_IRQHandler+0xec>
    {
      /* Clear the Transmission Complete flag (and TXOK1,ALST1,TERR1 bits) */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP1);
 800d968:	687b      	ldr	r3, [r7, #4]
 800d96a:	681b      	ldr	r3, [r3, #0]
 800d96c:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800d970:	609a      	str	r2, [r3, #8]

      if ((tsrflags & CAN_TSR_TXOK1) != 0U)
 800d972:	69bb      	ldr	r3, [r7, #24]
 800d974:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800d978:	2b00      	cmp	r3, #0
 800d97a:	d003      	beq.n	800d984 <HAL_CAN_IRQHandler+0xbe>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
        /* Call registered callback*/
        hcan->TxMailbox1CompleteCallback(hcan);
#else
        /* Call weak (surcharged) callback */
        HAL_CAN_TxMailbox1CompleteCallback(hcan);
 800d97c:	6878      	ldr	r0, [r7, #4]
 800d97e:	f000 f962 	bl	800dc46 <HAL_CAN_TxMailbox1CompleteCallback>
 800d982:	e016      	b.n	800d9b2 <HAL_CAN_IRQHandler+0xec>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
      }
      else
      {
        if ((tsrflags & CAN_TSR_ALST1) != 0U)
 800d984:	69bb      	ldr	r3, [r7, #24]
 800d986:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800d98a:	2b00      	cmp	r3, #0
 800d98c:	d004      	beq.n	800d998 <HAL_CAN_IRQHandler+0xd2>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_ALST1;
 800d98e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d990:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800d994:	627b      	str	r3, [r7, #36]	@ 0x24
 800d996:	e00c      	b.n	800d9b2 <HAL_CAN_IRQHandler+0xec>
        }
        else if ((tsrflags & CAN_TSR_TERR1) != 0U)
 800d998:	69bb      	ldr	r3, [r7, #24]
 800d99a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800d99e:	2b00      	cmp	r3, #0
 800d9a0:	d004      	beq.n	800d9ac <HAL_CAN_IRQHandler+0xe6>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_TERR1;
 800d9a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d9a4:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800d9a8:	627b      	str	r3, [r7, #36]	@ 0x24
 800d9aa:	e002      	b.n	800d9b2 <HAL_CAN_IRQHandler+0xec>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
          /* Call registered callback*/
          hcan->TxMailbox1AbortCallback(hcan);
#else
          /* Call weak (surcharged) callback */
          HAL_CAN_TxMailbox1AbortCallback(hcan);
 800d9ac:	6878      	ldr	r0, [r7, #4]
 800d9ae:	f000 f965 	bl	800dc7c <HAL_CAN_TxMailbox1AbortCallback>
        }
      }
    }

    /* Transmit Mailbox 2 management *****************************************/
    if ((tsrflags & CAN_TSR_RQCP2) != 0U)
 800d9b2:	69bb      	ldr	r3, [r7, #24]
 800d9b4:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800d9b8:	2b00      	cmp	r3, #0
 800d9ba:	d024      	beq.n	800da06 <HAL_CAN_IRQHandler+0x140>
    {
      /* Clear the Transmission Complete flag (and TXOK2,ALST2,TERR2 bits) */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP2);
 800d9bc:	687b      	ldr	r3, [r7, #4]
 800d9be:	681b      	ldr	r3, [r3, #0]
 800d9c0:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800d9c4:	609a      	str	r2, [r3, #8]

      if ((tsrflags & CAN_TSR_TXOK2) != 0U)
 800d9c6:	69bb      	ldr	r3, [r7, #24]
 800d9c8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800d9cc:	2b00      	cmp	r3, #0
 800d9ce:	d003      	beq.n	800d9d8 <HAL_CAN_IRQHandler+0x112>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
        /* Call registered callback*/
        hcan->TxMailbox2CompleteCallback(hcan);
#else
        /* Call weak (surcharged) callback */
        HAL_CAN_TxMailbox2CompleteCallback(hcan);
 800d9d0:	6878      	ldr	r0, [r7, #4]
 800d9d2:	f000 f941 	bl	800dc58 <HAL_CAN_TxMailbox2CompleteCallback>
 800d9d6:	e016      	b.n	800da06 <HAL_CAN_IRQHandler+0x140>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
      }
      else
      {
        if ((tsrflags & CAN_TSR_ALST2) != 0U)
 800d9d8:	69bb      	ldr	r3, [r7, #24]
 800d9da:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 800d9de:	2b00      	cmp	r3, #0
 800d9e0:	d004      	beq.n	800d9ec <HAL_CAN_IRQHandler+0x126>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_ALST2;
 800d9e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d9e4:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800d9e8:	627b      	str	r3, [r7, #36]	@ 0x24
 800d9ea:	e00c      	b.n	800da06 <HAL_CAN_IRQHandler+0x140>
        }
        else if ((tsrflags & CAN_TSR_TERR2) != 0U)
 800d9ec:	69bb      	ldr	r3, [r7, #24]
 800d9ee:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 800d9f2:	2b00      	cmp	r3, #0
 800d9f4:	d004      	beq.n	800da00 <HAL_CAN_IRQHandler+0x13a>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_TERR2;
 800d9f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d9f8:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800d9fc:	627b      	str	r3, [r7, #36]	@ 0x24
 800d9fe:	e002      	b.n	800da06 <HAL_CAN_IRQHandler+0x140>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
          /* Call registered callback*/
          hcan->TxMailbox2AbortCallback(hcan);
#else
          /* Call weak (surcharged) callback */
          HAL_CAN_TxMailbox2AbortCallback(hcan);
 800da00:	6878      	ldr	r0, [r7, #4]
 800da02:	f000 f944 	bl	800dc8e <HAL_CAN_TxMailbox2AbortCallback>
      }
    }
  }

  /* Receive FIFO 0 overrun interrupt management *****************************/
  if ((interrupts & CAN_IT_RX_FIFO0_OVERRUN) != 0U)
 800da06:	6a3b      	ldr	r3, [r7, #32]
 800da08:	f003 0308 	and.w	r3, r3, #8
 800da0c:	2b00      	cmp	r3, #0
 800da0e:	d00c      	beq.n	800da2a <HAL_CAN_IRQHandler+0x164>
  {
    if ((rf0rflags & CAN_RF0R_FOVR0) != 0U)
 800da10:	697b      	ldr	r3, [r7, #20]
 800da12:	f003 0310 	and.w	r3, r3, #16
 800da16:	2b00      	cmp	r3, #0
 800da18:	d007      	beq.n	800da2a <HAL_CAN_IRQHandler+0x164>
    {
      /* Set CAN error code to Rx Fifo 0 overrun error */
      errorcode |= HAL_CAN_ERROR_RX_FOV0;
 800da1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800da1c:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 800da20:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Clear FIFO0 Overrun Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);
 800da22:	687b      	ldr	r3, [r7, #4]
 800da24:	681b      	ldr	r3, [r3, #0]
 800da26:	2210      	movs	r2, #16
 800da28:	60da      	str	r2, [r3, #12]
    }
  }

  /* Receive FIFO 0 full interrupt management ********************************/
  if ((interrupts & CAN_IT_RX_FIFO0_FULL) != 0U)
 800da2a:	6a3b      	ldr	r3, [r7, #32]
 800da2c:	f003 0304 	and.w	r3, r3, #4
 800da30:	2b00      	cmp	r3, #0
 800da32:	d00b      	beq.n	800da4c <HAL_CAN_IRQHandler+0x186>
  {
    if ((rf0rflags & CAN_RF0R_FULL0) != 0U)
 800da34:	697b      	ldr	r3, [r7, #20]
 800da36:	f003 0308 	and.w	r3, r3, #8
 800da3a:	2b00      	cmp	r3, #0
 800da3c:	d006      	beq.n	800da4c <HAL_CAN_IRQHandler+0x186>
    {
      /* Clear FIFO 0 full Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF0);
 800da3e:	687b      	ldr	r3, [r7, #4]
 800da40:	681b      	ldr	r3, [r3, #0]
 800da42:	2208      	movs	r2, #8
 800da44:	60da      	str	r2, [r3, #12]
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->RxFifo0FullCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_RxFifo0FullCallback(hcan);
 800da46:	6878      	ldr	r0, [r7, #4]
 800da48:	f000 f92a 	bl	800dca0 <HAL_CAN_RxFifo0FullCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Receive FIFO 0 message pending interrupt management *********************/
  if ((interrupts & CAN_IT_RX_FIFO0_MSG_PENDING) != 0U)
 800da4c:	6a3b      	ldr	r3, [r7, #32]
 800da4e:	f003 0302 	and.w	r3, r3, #2
 800da52:	2b00      	cmp	r3, #0
 800da54:	d009      	beq.n	800da6a <HAL_CAN_IRQHandler+0x1a4>
  {
    /* Check if message is still pending */
    if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) != 0U)
 800da56:	687b      	ldr	r3, [r7, #4]
 800da58:	681b      	ldr	r3, [r3, #0]
 800da5a:	68db      	ldr	r3, [r3, #12]
 800da5c:	f003 0303 	and.w	r3, r3, #3
 800da60:	2b00      	cmp	r3, #0
 800da62:	d002      	beq.n	800da6a <HAL_CAN_IRQHandler+0x1a4>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->RxFifo0MsgPendingCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_RxFifo0MsgPendingCallback(hcan);
 800da64:	6878      	ldr	r0, [r7, #4]
 800da66:	f7ff f89b 	bl	800cba0 <HAL_CAN_RxFifo0MsgPendingCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Receive FIFO 1 overrun interrupt management *****************************/
  if ((interrupts & CAN_IT_RX_FIFO1_OVERRUN) != 0U)
 800da6a:	6a3b      	ldr	r3, [r7, #32]
 800da6c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800da70:	2b00      	cmp	r3, #0
 800da72:	d00c      	beq.n	800da8e <HAL_CAN_IRQHandler+0x1c8>
  {
    if ((rf1rflags & CAN_RF1R_FOVR1) != 0U)
 800da74:	693b      	ldr	r3, [r7, #16]
 800da76:	f003 0310 	and.w	r3, r3, #16
 800da7a:	2b00      	cmp	r3, #0
 800da7c:	d007      	beq.n	800da8e <HAL_CAN_IRQHandler+0x1c8>
    {
      /* Set CAN error code to Rx Fifo 1 overrun error */
      errorcode |= HAL_CAN_ERROR_RX_FOV1;
 800da7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800da80:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 800da84:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Clear FIFO1 Overrun Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);
 800da86:	687b      	ldr	r3, [r7, #4]
 800da88:	681b      	ldr	r3, [r3, #0]
 800da8a:	2210      	movs	r2, #16
 800da8c:	611a      	str	r2, [r3, #16]
    }
  }

  /* Receive FIFO 1 full interrupt management ********************************/
  if ((interrupts & CAN_IT_RX_FIFO1_FULL) != 0U)
 800da8e:	6a3b      	ldr	r3, [r7, #32]
 800da90:	f003 0320 	and.w	r3, r3, #32
 800da94:	2b00      	cmp	r3, #0
 800da96:	d00b      	beq.n	800dab0 <HAL_CAN_IRQHandler+0x1ea>
  {
    if ((rf1rflags & CAN_RF1R_FULL1) != 0U)
 800da98:	693b      	ldr	r3, [r7, #16]
 800da9a:	f003 0308 	and.w	r3, r3, #8
 800da9e:	2b00      	cmp	r3, #0
 800daa0:	d006      	beq.n	800dab0 <HAL_CAN_IRQHandler+0x1ea>
    {
      /* Clear FIFO 1 full Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF1);
 800daa2:	687b      	ldr	r3, [r7, #4]
 800daa4:	681b      	ldr	r3, [r3, #0]
 800daa6:	2208      	movs	r2, #8
 800daa8:	611a      	str	r2, [r3, #16]
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->RxFifo1FullCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_RxFifo1FullCallback(hcan);
 800daaa:	6878      	ldr	r0, [r7, #4]
 800daac:	f000 f90a 	bl	800dcc4 <HAL_CAN_RxFifo1FullCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Receive FIFO 1 message pending interrupt management *********************/
  if ((interrupts & CAN_IT_RX_FIFO1_MSG_PENDING) != 0U)
 800dab0:	6a3b      	ldr	r3, [r7, #32]
 800dab2:	f003 0310 	and.w	r3, r3, #16
 800dab6:	2b00      	cmp	r3, #0
 800dab8:	d009      	beq.n	800dace <HAL_CAN_IRQHandler+0x208>
  {
    /* Check if message is still pending */
    if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) != 0U)
 800daba:	687b      	ldr	r3, [r7, #4]
 800dabc:	681b      	ldr	r3, [r3, #0]
 800dabe:	691b      	ldr	r3, [r3, #16]
 800dac0:	f003 0303 	and.w	r3, r3, #3
 800dac4:	2b00      	cmp	r3, #0
 800dac6:	d002      	beq.n	800dace <HAL_CAN_IRQHandler+0x208>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->RxFifo1MsgPendingCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_RxFifo1MsgPendingCallback(hcan);
 800dac8:	6878      	ldr	r0, [r7, #4]
 800daca:	f000 f8f2 	bl	800dcb2 <HAL_CAN_RxFifo1MsgPendingCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Sleep interrupt management *********************************************/
  if ((interrupts & CAN_IT_SLEEP_ACK) != 0U)
 800dace:	6a3b      	ldr	r3, [r7, #32]
 800dad0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800dad4:	2b00      	cmp	r3, #0
 800dad6:	d00b      	beq.n	800daf0 <HAL_CAN_IRQHandler+0x22a>
  {
    if ((msrflags & CAN_MSR_SLAKI) != 0U)
 800dad8:	69fb      	ldr	r3, [r7, #28]
 800dada:	f003 0310 	and.w	r3, r3, #16
 800dade:	2b00      	cmp	r3, #0
 800dae0:	d006      	beq.n	800daf0 <HAL_CAN_IRQHandler+0x22a>
    {
      /* Clear Sleep interrupt Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_SLAKI);
 800dae2:	687b      	ldr	r3, [r7, #4]
 800dae4:	681b      	ldr	r3, [r3, #0]
 800dae6:	2210      	movs	r2, #16
 800dae8:	605a      	str	r2, [r3, #4]
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->SleepCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_SleepCallback(hcan);
 800daea:	6878      	ldr	r0, [r7, #4]
 800daec:	f000 f8f3 	bl	800dcd6 <HAL_CAN_SleepCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* WakeUp interrupt management *********************************************/
  if ((interrupts & CAN_IT_WAKEUP) != 0U)
 800daf0:	6a3b      	ldr	r3, [r7, #32]
 800daf2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800daf6:	2b00      	cmp	r3, #0
 800daf8:	d00b      	beq.n	800db12 <HAL_CAN_IRQHandler+0x24c>
  {
    if ((msrflags & CAN_MSR_WKUI) != 0U)
 800dafa:	69fb      	ldr	r3, [r7, #28]
 800dafc:	f003 0308 	and.w	r3, r3, #8
 800db00:	2b00      	cmp	r3, #0
 800db02:	d006      	beq.n	800db12 <HAL_CAN_IRQHandler+0x24c>
    {
      /* Clear WakeUp Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_WKU);
 800db04:	687b      	ldr	r3, [r7, #4]
 800db06:	681b      	ldr	r3, [r3, #0]
 800db08:	2208      	movs	r2, #8
 800db0a:	605a      	str	r2, [r3, #4]
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->WakeUpFromRxMsgCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_WakeUpFromRxMsgCallback(hcan);
 800db0c:	6878      	ldr	r0, [r7, #4]
 800db0e:	f000 f8eb 	bl	800dce8 <HAL_CAN_WakeUpFromRxMsgCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Error interrupts management *********************************************/
  if ((interrupts & CAN_IT_ERROR) != 0U)
 800db12:	6a3b      	ldr	r3, [r7, #32]
 800db14:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 800db18:	2b00      	cmp	r3, #0
 800db1a:	d07b      	beq.n	800dc14 <HAL_CAN_IRQHandler+0x34e>
  {
    if ((msrflags & CAN_MSR_ERRI) != 0U)
 800db1c:	69fb      	ldr	r3, [r7, #28]
 800db1e:	f003 0304 	and.w	r3, r3, #4
 800db22:	2b00      	cmp	r3, #0
 800db24:	d072      	beq.n	800dc0c <HAL_CAN_IRQHandler+0x346>
    {
      /* Check Error Warning Flag */
      if (((interrupts & CAN_IT_ERROR_WARNING) != 0U) &&
 800db26:	6a3b      	ldr	r3, [r7, #32]
 800db28:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800db2c:	2b00      	cmp	r3, #0
 800db2e:	d008      	beq.n	800db42 <HAL_CAN_IRQHandler+0x27c>
          ((esrflags & CAN_ESR_EWGF) != 0U))
 800db30:	68fb      	ldr	r3, [r7, #12]
 800db32:	f003 0301 	and.w	r3, r3, #1
      if (((interrupts & CAN_IT_ERROR_WARNING) != 0U) &&
 800db36:	2b00      	cmp	r3, #0
 800db38:	d003      	beq.n	800db42 <HAL_CAN_IRQHandler+0x27c>
      {
        /* Set CAN error code to Error Warning */
        errorcode |= HAL_CAN_ERROR_EWG;
 800db3a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800db3c:	f043 0301 	orr.w	r3, r3, #1
 800db40:	627b      	str	r3, [r7, #36]	@ 0x24

        /* No need for clear of Error Warning Flag as read-only */
      }

      /* Check Error Passive Flag */
      if (((interrupts & CAN_IT_ERROR_PASSIVE) != 0U) &&
 800db42:	6a3b      	ldr	r3, [r7, #32]
 800db44:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800db48:	2b00      	cmp	r3, #0
 800db4a:	d008      	beq.n	800db5e <HAL_CAN_IRQHandler+0x298>
          ((esrflags & CAN_ESR_EPVF) != 0U))
 800db4c:	68fb      	ldr	r3, [r7, #12]
 800db4e:	f003 0302 	and.w	r3, r3, #2
      if (((interrupts & CAN_IT_ERROR_PASSIVE) != 0U) &&
 800db52:	2b00      	cmp	r3, #0
 800db54:	d003      	beq.n	800db5e <HAL_CAN_IRQHandler+0x298>
      {
        /* Set CAN error code to Error Passive */
        errorcode |= HAL_CAN_ERROR_EPV;
 800db56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800db58:	f043 0302 	orr.w	r3, r3, #2
 800db5c:	627b      	str	r3, [r7, #36]	@ 0x24

        /* No need for clear of Error Passive Flag as read-only */
      }

      /* Check Bus-off Flag */
      if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
 800db5e:	6a3b      	ldr	r3, [r7, #32]
 800db60:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800db64:	2b00      	cmp	r3, #0
 800db66:	d008      	beq.n	800db7a <HAL_CAN_IRQHandler+0x2b4>
          ((esrflags & CAN_ESR_BOFF) != 0U))
 800db68:	68fb      	ldr	r3, [r7, #12]
 800db6a:	f003 0304 	and.w	r3, r3, #4
      if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
 800db6e:	2b00      	cmp	r3, #0
 800db70:	d003      	beq.n	800db7a <HAL_CAN_IRQHandler+0x2b4>
      {
        /* Set CAN error code to Bus-Off */
        errorcode |= HAL_CAN_ERROR_BOF;
 800db72:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800db74:	f043 0304 	orr.w	r3, r3, #4
 800db78:	627b      	str	r3, [r7, #36]	@ 0x24

        /* No need for clear of Error Bus-Off as read-only */
      }

      /* Check Last Error Code Flag */
      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
 800db7a:	6a3b      	ldr	r3, [r7, #32]
 800db7c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800db80:	2b00      	cmp	r3, #0
 800db82:	d043      	beq.n	800dc0c <HAL_CAN_IRQHandler+0x346>
          ((esrflags & CAN_ESR_LEC) != 0U))
 800db84:	68fb      	ldr	r3, [r7, #12]
 800db86:	f003 0370 	and.w	r3, r3, #112	@ 0x70
      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
 800db8a:	2b00      	cmp	r3, #0
 800db8c:	d03e      	beq.n	800dc0c <HAL_CAN_IRQHandler+0x346>
      {
        switch (esrflags & CAN_ESR_LEC)
 800db8e:	68fb      	ldr	r3, [r7, #12]
 800db90:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800db94:	2b60      	cmp	r3, #96	@ 0x60
 800db96:	d02b      	beq.n	800dbf0 <HAL_CAN_IRQHandler+0x32a>
 800db98:	2b60      	cmp	r3, #96	@ 0x60
 800db9a:	d82e      	bhi.n	800dbfa <HAL_CAN_IRQHandler+0x334>
 800db9c:	2b50      	cmp	r3, #80	@ 0x50
 800db9e:	d022      	beq.n	800dbe6 <HAL_CAN_IRQHandler+0x320>
 800dba0:	2b50      	cmp	r3, #80	@ 0x50
 800dba2:	d82a      	bhi.n	800dbfa <HAL_CAN_IRQHandler+0x334>
 800dba4:	2b40      	cmp	r3, #64	@ 0x40
 800dba6:	d019      	beq.n	800dbdc <HAL_CAN_IRQHandler+0x316>
 800dba8:	2b40      	cmp	r3, #64	@ 0x40
 800dbaa:	d826      	bhi.n	800dbfa <HAL_CAN_IRQHandler+0x334>
 800dbac:	2b30      	cmp	r3, #48	@ 0x30
 800dbae:	d010      	beq.n	800dbd2 <HAL_CAN_IRQHandler+0x30c>
 800dbb0:	2b30      	cmp	r3, #48	@ 0x30
 800dbb2:	d822      	bhi.n	800dbfa <HAL_CAN_IRQHandler+0x334>
 800dbb4:	2b10      	cmp	r3, #16
 800dbb6:	d002      	beq.n	800dbbe <HAL_CAN_IRQHandler+0x2f8>
 800dbb8:	2b20      	cmp	r3, #32
 800dbba:	d005      	beq.n	800dbc8 <HAL_CAN_IRQHandler+0x302>
          case (CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
            /* Set CAN error code to CRC error */
            errorcode |= HAL_CAN_ERROR_CRC;
            break;
          default:
            break;
 800dbbc:	e01d      	b.n	800dbfa <HAL_CAN_IRQHandler+0x334>
            errorcode |= HAL_CAN_ERROR_STF;
 800dbbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dbc0:	f043 0308 	orr.w	r3, r3, #8
 800dbc4:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 800dbc6:	e019      	b.n	800dbfc <HAL_CAN_IRQHandler+0x336>
            errorcode |= HAL_CAN_ERROR_FOR;
 800dbc8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dbca:	f043 0310 	orr.w	r3, r3, #16
 800dbce:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 800dbd0:	e014      	b.n	800dbfc <HAL_CAN_IRQHandler+0x336>
            errorcode |= HAL_CAN_ERROR_ACK;
 800dbd2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dbd4:	f043 0320 	orr.w	r3, r3, #32
 800dbd8:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 800dbda:	e00f      	b.n	800dbfc <HAL_CAN_IRQHandler+0x336>
            errorcode |= HAL_CAN_ERROR_BR;
 800dbdc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dbde:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800dbe2:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 800dbe4:	e00a      	b.n	800dbfc <HAL_CAN_IRQHandler+0x336>
            errorcode |= HAL_CAN_ERROR_BD;
 800dbe6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dbe8:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800dbec:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 800dbee:	e005      	b.n	800dbfc <HAL_CAN_IRQHandler+0x336>
            errorcode |= HAL_CAN_ERROR_CRC;
 800dbf0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dbf2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800dbf6:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 800dbf8:	e000      	b.n	800dbfc <HAL_CAN_IRQHandler+0x336>
            break;
 800dbfa:	bf00      	nop
        }

        /* Clear Last error code Flag */
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 800dbfc:	687b      	ldr	r3, [r7, #4]
 800dbfe:	681b      	ldr	r3, [r3, #0]
 800dc00:	699a      	ldr	r2, [r3, #24]
 800dc02:	687b      	ldr	r3, [r7, #4]
 800dc04:	681b      	ldr	r3, [r3, #0]
 800dc06:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800dc0a:	619a      	str	r2, [r3, #24]
      }
    }

    /* Clear ERRI Flag */
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 800dc0c:	687b      	ldr	r3, [r7, #4]
 800dc0e:	681b      	ldr	r3, [r3, #0]
 800dc10:	2204      	movs	r2, #4
 800dc12:	605a      	str	r2, [r3, #4]
  }

  /* Call the Error call Back in case of Errors */
  if (errorcode != HAL_CAN_ERROR_NONE)
 800dc14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dc16:	2b00      	cmp	r3, #0
 800dc18:	d008      	beq.n	800dc2c <HAL_CAN_IRQHandler+0x366>
  {
    /* Update error code in handle */
    hcan->ErrorCode |= errorcode;
 800dc1a:	687b      	ldr	r3, [r7, #4]
 800dc1c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800dc1e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dc20:	431a      	orrs	r2, r3
 800dc22:	687b      	ldr	r3, [r7, #4]
 800dc24:	625a      	str	r2, [r3, #36]	@ 0x24
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
    /* Call registered callback*/
    hcan->ErrorCallback(hcan);
#else
    /* Call weak (surcharged) callback */
    HAL_CAN_ErrorCallback(hcan);
 800dc26:	6878      	ldr	r0, [r7, #4]
 800dc28:	f000 f867 	bl	800dcfa <HAL_CAN_ErrorCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
  }
}
 800dc2c:	bf00      	nop
 800dc2e:	3728      	adds	r7, #40	@ 0x28
 800dc30:	46bd      	mov	sp, r7
 800dc32:	bd80      	pop	{r7, pc}

0800dc34 <HAL_CAN_TxMailbox0CompleteCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
{
 800dc34:	b480      	push	{r7}
 800dc36:	b083      	sub	sp, #12
 800dc38:	af00      	add	r7, sp, #0
 800dc3a:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox0CompleteCallback could be implemented in the
            user file
   */
}
 800dc3c:	bf00      	nop
 800dc3e:	370c      	adds	r7, #12
 800dc40:	46bd      	mov	sp, r7
 800dc42:	bc80      	pop	{r7}
 800dc44:	4770      	bx	lr

0800dc46 <HAL_CAN_TxMailbox1CompleteCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)
{
 800dc46:	b480      	push	{r7}
 800dc48:	b083      	sub	sp, #12
 800dc4a:	af00      	add	r7, sp, #0
 800dc4c:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox1CompleteCallback could be implemented in the
            user file
   */
}
 800dc4e:	bf00      	nop
 800dc50:	370c      	adds	r7, #12
 800dc52:	46bd      	mov	sp, r7
 800dc54:	bc80      	pop	{r7}
 800dc56:	4770      	bx	lr

0800dc58 <HAL_CAN_TxMailbox2CompleteCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)
{
 800dc58:	b480      	push	{r7}
 800dc5a:	b083      	sub	sp, #12
 800dc5c:	af00      	add	r7, sp, #0
 800dc5e:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox2CompleteCallback could be implemented in the
            user file
   */
}
 800dc60:	bf00      	nop
 800dc62:	370c      	adds	r7, #12
 800dc64:	46bd      	mov	sp, r7
 800dc66:	bc80      	pop	{r7}
 800dc68:	4770      	bx	lr

0800dc6a <HAL_CAN_TxMailbox0AbortCallback>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef *hcan)
{
 800dc6a:	b480      	push	{r7}
 800dc6c:	b083      	sub	sp, #12
 800dc6e:	af00      	add	r7, sp, #0
 800dc70:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox0AbortCallback could be implemented in the
            user file
   */
}
 800dc72:	bf00      	nop
 800dc74:	370c      	adds	r7, #12
 800dc76:	46bd      	mov	sp, r7
 800dc78:	bc80      	pop	{r7}
 800dc7a:	4770      	bx	lr

0800dc7c <HAL_CAN_TxMailbox1AbortCallback>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef *hcan)
{
 800dc7c:	b480      	push	{r7}
 800dc7e:	b083      	sub	sp, #12
 800dc80:	af00      	add	r7, sp, #0
 800dc82:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox1AbortCallback could be implemented in the
            user file
   */
}
 800dc84:	bf00      	nop
 800dc86:	370c      	adds	r7, #12
 800dc88:	46bd      	mov	sp, r7
 800dc8a:	bc80      	pop	{r7}
 800dc8c:	4770      	bx	lr

0800dc8e <HAL_CAN_TxMailbox2AbortCallback>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef *hcan)
{
 800dc8e:	b480      	push	{r7}
 800dc90:	b083      	sub	sp, #12
 800dc92:	af00      	add	r7, sp, #0
 800dc94:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox2AbortCallback could be implemented in the
            user file
   */
}
 800dc96:	bf00      	nop
 800dc98:	370c      	adds	r7, #12
 800dc9a:	46bd      	mov	sp, r7
 800dc9c:	bc80      	pop	{r7}
 800dc9e:	4770      	bx	lr

0800dca0 <HAL_CAN_RxFifo0FullCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *hcan)
{
 800dca0:	b480      	push	{r7}
 800dca2:	b083      	sub	sp, #12
 800dca4:	af00      	add	r7, sp, #0
 800dca6:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_RxFifo0FullCallback could be implemented in the user
            file
   */
}
 800dca8:	bf00      	nop
 800dcaa:	370c      	adds	r7, #12
 800dcac:	46bd      	mov	sp, r7
 800dcae:	bc80      	pop	{r7}
 800dcb0:	4770      	bx	lr

0800dcb2 <HAL_CAN_RxFifo1MsgPendingCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
 800dcb2:	b480      	push	{r7}
 800dcb4:	b083      	sub	sp, #12
 800dcb6:	af00      	add	r7, sp, #0
 800dcb8:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_RxFifo1MsgPendingCallback could be implemented in the
            user file
   */
}
 800dcba:	bf00      	nop
 800dcbc:	370c      	adds	r7, #12
 800dcbe:	46bd      	mov	sp, r7
 800dcc0:	bc80      	pop	{r7}
 800dcc2:	4770      	bx	lr

0800dcc4 <HAL_CAN_RxFifo1FullCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *hcan)
{
 800dcc4:	b480      	push	{r7}
 800dcc6:	b083      	sub	sp, #12
 800dcc8:	af00      	add	r7, sp, #0
 800dcca:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_RxFifo1FullCallback could be implemented in the user
            file
   */
}
 800dccc:	bf00      	nop
 800dcce:	370c      	adds	r7, #12
 800dcd0:	46bd      	mov	sp, r7
 800dcd2:	bc80      	pop	{r7}
 800dcd4:	4770      	bx	lr

0800dcd6 <HAL_CAN_SleepCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_SleepCallback(CAN_HandleTypeDef *hcan)
{
 800dcd6:	b480      	push	{r7}
 800dcd8:	b083      	sub	sp, #12
 800dcda:	af00      	add	r7, sp, #0
 800dcdc:	6078      	str	r0, [r7, #4]
  UNUSED(hcan);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_SleepCallback could be implemented in the user file
   */
}
 800dcde:	bf00      	nop
 800dce0:	370c      	adds	r7, #12
 800dce2:	46bd      	mov	sp, r7
 800dce4:	bc80      	pop	{r7}
 800dce6:	4770      	bx	lr

0800dce8 <HAL_CAN_WakeUpFromRxMsgCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef *hcan)
{
 800dce8:	b480      	push	{r7}
 800dcea:	b083      	sub	sp, #12
 800dcec:	af00      	add	r7, sp, #0
 800dcee:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_WakeUpFromRxMsgCallback could be implemented in the
            user file
   */
}
 800dcf0:	bf00      	nop
 800dcf2:	370c      	adds	r7, #12
 800dcf4:	46bd      	mov	sp, r7
 800dcf6:	bc80      	pop	{r7}
 800dcf8:	4770      	bx	lr

0800dcfa <HAL_CAN_ErrorCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
{
 800dcfa:	b480      	push	{r7}
 800dcfc:	b083      	sub	sp, #12
 800dcfe:	af00      	add	r7, sp, #0
 800dd00:	6078      	str	r0, [r7, #4]
  UNUSED(hcan);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_ErrorCallback could be implemented in the user file
   */
}
 800dd02:	bf00      	nop
 800dd04:	370c      	adds	r7, #12
 800dd06:	46bd      	mov	sp, r7
 800dd08:	bc80      	pop	{r7}
 800dd0a:	4770      	bx	lr

0800dd0c <__NVIC_SetPriorityGrouping>:
{
 800dd0c:	b480      	push	{r7}
 800dd0e:	b085      	sub	sp, #20
 800dd10:	af00      	add	r7, sp, #0
 800dd12:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800dd14:	687b      	ldr	r3, [r7, #4]
 800dd16:	f003 0307 	and.w	r3, r3, #7
 800dd1a:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800dd1c:	4b0c      	ldr	r3, [pc, #48]	@ (800dd50 <__NVIC_SetPriorityGrouping+0x44>)
 800dd1e:	68db      	ldr	r3, [r3, #12]
 800dd20:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800dd22:	68ba      	ldr	r2, [r7, #8]
 800dd24:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 800dd28:	4013      	ands	r3, r2
 800dd2a:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 800dd2c:	68fb      	ldr	r3, [r7, #12]
 800dd2e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800dd30:	68bb      	ldr	r3, [r7, #8]
 800dd32:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800dd34:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800dd38:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800dd3c:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800dd3e:	4a04      	ldr	r2, [pc, #16]	@ (800dd50 <__NVIC_SetPriorityGrouping+0x44>)
 800dd40:	68bb      	ldr	r3, [r7, #8]
 800dd42:	60d3      	str	r3, [r2, #12]
}
 800dd44:	bf00      	nop
 800dd46:	3714      	adds	r7, #20
 800dd48:	46bd      	mov	sp, r7
 800dd4a:	bc80      	pop	{r7}
 800dd4c:	4770      	bx	lr
 800dd4e:	bf00      	nop
 800dd50:	e000ed00 	.word	0xe000ed00

0800dd54 <__NVIC_GetPriorityGrouping>:
{
 800dd54:	b480      	push	{r7}
 800dd56:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800dd58:	4b04      	ldr	r3, [pc, #16]	@ (800dd6c <__NVIC_GetPriorityGrouping+0x18>)
 800dd5a:	68db      	ldr	r3, [r3, #12]
 800dd5c:	0a1b      	lsrs	r3, r3, #8
 800dd5e:	f003 0307 	and.w	r3, r3, #7
}
 800dd62:	4618      	mov	r0, r3
 800dd64:	46bd      	mov	sp, r7
 800dd66:	bc80      	pop	{r7}
 800dd68:	4770      	bx	lr
 800dd6a:	bf00      	nop
 800dd6c:	e000ed00 	.word	0xe000ed00

0800dd70 <__NVIC_EnableIRQ>:
{
 800dd70:	b480      	push	{r7}
 800dd72:	b083      	sub	sp, #12
 800dd74:	af00      	add	r7, sp, #0
 800dd76:	4603      	mov	r3, r0
 800dd78:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800dd7a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800dd7e:	2b00      	cmp	r3, #0
 800dd80:	db0b      	blt.n	800dd9a <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800dd82:	79fb      	ldrb	r3, [r7, #7]
 800dd84:	f003 021f 	and.w	r2, r3, #31
 800dd88:	4906      	ldr	r1, [pc, #24]	@ (800dda4 <__NVIC_EnableIRQ+0x34>)
 800dd8a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800dd8e:	095b      	lsrs	r3, r3, #5
 800dd90:	2001      	movs	r0, #1
 800dd92:	fa00 f202 	lsl.w	r2, r0, r2
 800dd96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800dd9a:	bf00      	nop
 800dd9c:	370c      	adds	r7, #12
 800dd9e:	46bd      	mov	sp, r7
 800dda0:	bc80      	pop	{r7}
 800dda2:	4770      	bx	lr
 800dda4:	e000e100 	.word	0xe000e100

0800dda8 <__NVIC_SetPriority>:
{
 800dda8:	b480      	push	{r7}
 800ddaa:	b083      	sub	sp, #12
 800ddac:	af00      	add	r7, sp, #0
 800ddae:	4603      	mov	r3, r0
 800ddb0:	6039      	str	r1, [r7, #0]
 800ddb2:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800ddb4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800ddb8:	2b00      	cmp	r3, #0
 800ddba:	db0a      	blt.n	800ddd2 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800ddbc:	683b      	ldr	r3, [r7, #0]
 800ddbe:	b2da      	uxtb	r2, r3
 800ddc0:	490c      	ldr	r1, [pc, #48]	@ (800ddf4 <__NVIC_SetPriority+0x4c>)
 800ddc2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800ddc6:	0112      	lsls	r2, r2, #4
 800ddc8:	b2d2      	uxtb	r2, r2
 800ddca:	440b      	add	r3, r1
 800ddcc:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
 800ddd0:	e00a      	b.n	800dde8 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800ddd2:	683b      	ldr	r3, [r7, #0]
 800ddd4:	b2da      	uxtb	r2, r3
 800ddd6:	4908      	ldr	r1, [pc, #32]	@ (800ddf8 <__NVIC_SetPriority+0x50>)
 800ddd8:	79fb      	ldrb	r3, [r7, #7]
 800ddda:	f003 030f 	and.w	r3, r3, #15
 800ddde:	3b04      	subs	r3, #4
 800dde0:	0112      	lsls	r2, r2, #4
 800dde2:	b2d2      	uxtb	r2, r2
 800dde4:	440b      	add	r3, r1
 800dde6:	761a      	strb	r2, [r3, #24]
}
 800dde8:	bf00      	nop
 800ddea:	370c      	adds	r7, #12
 800ddec:	46bd      	mov	sp, r7
 800ddee:	bc80      	pop	{r7}
 800ddf0:	4770      	bx	lr
 800ddf2:	bf00      	nop
 800ddf4:	e000e100 	.word	0xe000e100
 800ddf8:	e000ed00 	.word	0xe000ed00

0800ddfc <NVIC_EncodePriority>:
{
 800ddfc:	b480      	push	{r7}
 800ddfe:	b089      	sub	sp, #36	@ 0x24
 800de00:	af00      	add	r7, sp, #0
 800de02:	60f8      	str	r0, [r7, #12]
 800de04:	60b9      	str	r1, [r7, #8]
 800de06:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800de08:	68fb      	ldr	r3, [r7, #12]
 800de0a:	f003 0307 	and.w	r3, r3, #7
 800de0e:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800de10:	69fb      	ldr	r3, [r7, #28]
 800de12:	f1c3 0307 	rsb	r3, r3, #7
 800de16:	2b04      	cmp	r3, #4
 800de18:	bf28      	it	cs
 800de1a:	2304      	movcs	r3, #4
 800de1c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800de1e:	69fb      	ldr	r3, [r7, #28]
 800de20:	3304      	adds	r3, #4
 800de22:	2b06      	cmp	r3, #6
 800de24:	d902      	bls.n	800de2c <NVIC_EncodePriority+0x30>
 800de26:	69fb      	ldr	r3, [r7, #28]
 800de28:	3b03      	subs	r3, #3
 800de2a:	e000      	b.n	800de2e <NVIC_EncodePriority+0x32>
 800de2c:	2300      	movs	r3, #0
 800de2e:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800de30:	f04f 32ff 	mov.w	r2, #4294967295
 800de34:	69bb      	ldr	r3, [r7, #24]
 800de36:	fa02 f303 	lsl.w	r3, r2, r3
 800de3a:	43da      	mvns	r2, r3
 800de3c:	68bb      	ldr	r3, [r7, #8]
 800de3e:	401a      	ands	r2, r3
 800de40:	697b      	ldr	r3, [r7, #20]
 800de42:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800de44:	f04f 31ff 	mov.w	r1, #4294967295
 800de48:	697b      	ldr	r3, [r7, #20]
 800de4a:	fa01 f303 	lsl.w	r3, r1, r3
 800de4e:	43d9      	mvns	r1, r3
 800de50:	687b      	ldr	r3, [r7, #4]
 800de52:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800de54:	4313      	orrs	r3, r2
}
 800de56:	4618      	mov	r0, r3
 800de58:	3724      	adds	r7, #36	@ 0x24
 800de5a:	46bd      	mov	sp, r7
 800de5c:	bc80      	pop	{r7}
 800de5e:	4770      	bx	lr

0800de60 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800de60:	b580      	push	{r7, lr}
 800de62:	b082      	sub	sp, #8
 800de64:	af00      	add	r7, sp, #0
 800de66:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800de68:	687b      	ldr	r3, [r7, #4]
 800de6a:	3b01      	subs	r3, #1
 800de6c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 800de70:	d301      	bcc.n	800de76 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800de72:	2301      	movs	r3, #1
 800de74:	e00f      	b.n	800de96 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800de76:	4a0a      	ldr	r2, [pc, #40]	@ (800dea0 <SysTick_Config+0x40>)
 800de78:	687b      	ldr	r3, [r7, #4]
 800de7a:	3b01      	subs	r3, #1
 800de7c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800de7e:	210f      	movs	r1, #15
 800de80:	f04f 30ff 	mov.w	r0, #4294967295
 800de84:	f7ff ff90 	bl	800dda8 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800de88:	4b05      	ldr	r3, [pc, #20]	@ (800dea0 <SysTick_Config+0x40>)
 800de8a:	2200      	movs	r2, #0
 800de8c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800de8e:	4b04      	ldr	r3, [pc, #16]	@ (800dea0 <SysTick_Config+0x40>)
 800de90:	2207      	movs	r2, #7
 800de92:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800de94:	2300      	movs	r3, #0
}
 800de96:	4618      	mov	r0, r3
 800de98:	3708      	adds	r7, #8
 800de9a:	46bd      	mov	sp, r7
 800de9c:	bd80      	pop	{r7, pc}
 800de9e:	bf00      	nop
 800dea0:	e000e010 	.word	0xe000e010

0800dea4 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800dea4:	b580      	push	{r7, lr}
 800dea6:	b082      	sub	sp, #8
 800dea8:	af00      	add	r7, sp, #0
 800deaa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800deac:	6878      	ldr	r0, [r7, #4]
 800deae:	f7ff ff2d 	bl	800dd0c <__NVIC_SetPriorityGrouping>
}
 800deb2:	bf00      	nop
 800deb4:	3708      	adds	r7, #8
 800deb6:	46bd      	mov	sp, r7
 800deb8:	bd80      	pop	{r7, pc}

0800deba <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800deba:	b580      	push	{r7, lr}
 800debc:	b086      	sub	sp, #24
 800debe:	af00      	add	r7, sp, #0
 800dec0:	4603      	mov	r3, r0
 800dec2:	60b9      	str	r1, [r7, #8]
 800dec4:	607a      	str	r2, [r7, #4]
 800dec6:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 800dec8:	2300      	movs	r3, #0
 800deca:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800decc:	f7ff ff42 	bl	800dd54 <__NVIC_GetPriorityGrouping>
 800ded0:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800ded2:	687a      	ldr	r2, [r7, #4]
 800ded4:	68b9      	ldr	r1, [r7, #8]
 800ded6:	6978      	ldr	r0, [r7, #20]
 800ded8:	f7ff ff90 	bl	800ddfc <NVIC_EncodePriority>
 800dedc:	4602      	mov	r2, r0
 800dede:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800dee2:	4611      	mov	r1, r2
 800dee4:	4618      	mov	r0, r3
 800dee6:	f7ff ff5f 	bl	800dda8 <__NVIC_SetPriority>
}
 800deea:	bf00      	nop
 800deec:	3718      	adds	r7, #24
 800deee:	46bd      	mov	sp, r7
 800def0:	bd80      	pop	{r7, pc}

0800def2 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f10xxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800def2:	b580      	push	{r7, lr}
 800def4:	b082      	sub	sp, #8
 800def6:	af00      	add	r7, sp, #0
 800def8:	4603      	mov	r3, r0
 800defa:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800defc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800df00:	4618      	mov	r0, r3
 800df02:	f7ff ff35 	bl	800dd70 <__NVIC_EnableIRQ>
}
 800df06:	bf00      	nop
 800df08:	3708      	adds	r7, #8
 800df0a:	46bd      	mov	sp, r7
 800df0c:	bd80      	pop	{r7, pc}

0800df0e <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800df0e:	b580      	push	{r7, lr}
 800df10:	b082      	sub	sp, #8
 800df12:	af00      	add	r7, sp, #0
 800df14:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800df16:	6878      	ldr	r0, [r7, #4]
 800df18:	f7ff ffa2 	bl	800de60 <SysTick_Config>
 800df1c:	4603      	mov	r3, r0
}
 800df1e:	4618      	mov	r0, r3
 800df20:	3708      	adds	r7, #8
 800df22:	46bd      	mov	sp, r7
 800df24:	bd80      	pop	{r7, pc}
	...

0800df28 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800df28:	b480      	push	{r7}
 800df2a:	b08b      	sub	sp, #44	@ 0x2c
 800df2c:	af00      	add	r7, sp, #0
 800df2e:	6078      	str	r0, [r7, #4]
 800df30:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 800df32:	2300      	movs	r3, #0
 800df34:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t ioposition;
  uint32_t iocurrent;
  uint32_t temp;
  uint32_t config = 0x00u;
 800df36:	2300      	movs	r3, #0
 800df38:	623b      	str	r3, [r7, #32]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800df3a:	e169      	b.n	800e210 <HAL_GPIO_Init+0x2e8>
  {
    /* Get the IO position */
    ioposition = (0x01uL << position);
 800df3c:	2201      	movs	r2, #1
 800df3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800df40:	fa02 f303 	lsl.w	r3, r2, r3
 800df44:	61fb      	str	r3, [r7, #28]

    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800df46:	683b      	ldr	r3, [r7, #0]
 800df48:	681b      	ldr	r3, [r3, #0]
 800df4a:	69fa      	ldr	r2, [r7, #28]
 800df4c:	4013      	ands	r3, r2
 800df4e:	61bb      	str	r3, [r7, #24]

    if (iocurrent == ioposition)
 800df50:	69ba      	ldr	r2, [r7, #24]
 800df52:	69fb      	ldr	r3, [r7, #28]
 800df54:	429a      	cmp	r2, r3
 800df56:	f040 8158 	bne.w	800e20a <HAL_GPIO_Init+0x2e2>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 800df5a:	683b      	ldr	r3, [r7, #0]
 800df5c:	685b      	ldr	r3, [r3, #4]
 800df5e:	4a9a      	ldr	r2, [pc, #616]	@ (800e1c8 <HAL_GPIO_Init+0x2a0>)
 800df60:	4293      	cmp	r3, r2
 800df62:	d05e      	beq.n	800e022 <HAL_GPIO_Init+0xfa>
 800df64:	4a98      	ldr	r2, [pc, #608]	@ (800e1c8 <HAL_GPIO_Init+0x2a0>)
 800df66:	4293      	cmp	r3, r2
 800df68:	d875      	bhi.n	800e056 <HAL_GPIO_Init+0x12e>
 800df6a:	4a98      	ldr	r2, [pc, #608]	@ (800e1cc <HAL_GPIO_Init+0x2a4>)
 800df6c:	4293      	cmp	r3, r2
 800df6e:	d058      	beq.n	800e022 <HAL_GPIO_Init+0xfa>
 800df70:	4a96      	ldr	r2, [pc, #600]	@ (800e1cc <HAL_GPIO_Init+0x2a4>)
 800df72:	4293      	cmp	r3, r2
 800df74:	d86f      	bhi.n	800e056 <HAL_GPIO_Init+0x12e>
 800df76:	4a96      	ldr	r2, [pc, #600]	@ (800e1d0 <HAL_GPIO_Init+0x2a8>)
 800df78:	4293      	cmp	r3, r2
 800df7a:	d052      	beq.n	800e022 <HAL_GPIO_Init+0xfa>
 800df7c:	4a94      	ldr	r2, [pc, #592]	@ (800e1d0 <HAL_GPIO_Init+0x2a8>)
 800df7e:	4293      	cmp	r3, r2
 800df80:	d869      	bhi.n	800e056 <HAL_GPIO_Init+0x12e>
 800df82:	4a94      	ldr	r2, [pc, #592]	@ (800e1d4 <HAL_GPIO_Init+0x2ac>)
 800df84:	4293      	cmp	r3, r2
 800df86:	d04c      	beq.n	800e022 <HAL_GPIO_Init+0xfa>
 800df88:	4a92      	ldr	r2, [pc, #584]	@ (800e1d4 <HAL_GPIO_Init+0x2ac>)
 800df8a:	4293      	cmp	r3, r2
 800df8c:	d863      	bhi.n	800e056 <HAL_GPIO_Init+0x12e>
 800df8e:	4a92      	ldr	r2, [pc, #584]	@ (800e1d8 <HAL_GPIO_Init+0x2b0>)
 800df90:	4293      	cmp	r3, r2
 800df92:	d046      	beq.n	800e022 <HAL_GPIO_Init+0xfa>
 800df94:	4a90      	ldr	r2, [pc, #576]	@ (800e1d8 <HAL_GPIO_Init+0x2b0>)
 800df96:	4293      	cmp	r3, r2
 800df98:	d85d      	bhi.n	800e056 <HAL_GPIO_Init+0x12e>
 800df9a:	2b12      	cmp	r3, #18
 800df9c:	d82a      	bhi.n	800dff4 <HAL_GPIO_Init+0xcc>
 800df9e:	2b12      	cmp	r3, #18
 800dfa0:	d859      	bhi.n	800e056 <HAL_GPIO_Init+0x12e>
 800dfa2:	a201      	add	r2, pc, #4	@ (adr r2, 800dfa8 <HAL_GPIO_Init+0x80>)
 800dfa4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800dfa8:	0800e023 	.word	0x0800e023
 800dfac:	0800dffd 	.word	0x0800dffd
 800dfb0:	0800e00f 	.word	0x0800e00f
 800dfb4:	0800e051 	.word	0x0800e051
 800dfb8:	0800e057 	.word	0x0800e057
 800dfbc:	0800e057 	.word	0x0800e057
 800dfc0:	0800e057 	.word	0x0800e057
 800dfc4:	0800e057 	.word	0x0800e057
 800dfc8:	0800e057 	.word	0x0800e057
 800dfcc:	0800e057 	.word	0x0800e057
 800dfd0:	0800e057 	.word	0x0800e057
 800dfd4:	0800e057 	.word	0x0800e057
 800dfd8:	0800e057 	.word	0x0800e057
 800dfdc:	0800e057 	.word	0x0800e057
 800dfe0:	0800e057 	.word	0x0800e057
 800dfe4:	0800e057 	.word	0x0800e057
 800dfe8:	0800e057 	.word	0x0800e057
 800dfec:	0800e005 	.word	0x0800e005
 800dff0:	0800e019 	.word	0x0800e019
 800dff4:	4a79      	ldr	r2, [pc, #484]	@ (800e1dc <HAL_GPIO_Init+0x2b4>)
 800dff6:	4293      	cmp	r3, r2
 800dff8:	d013      	beq.n	800e022 <HAL_GPIO_Init+0xfa>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
          break;

        /* Parameters are checked with assert_param */
        default:
          break;
 800dffa:	e02c      	b.n	800e056 <HAL_GPIO_Init+0x12e>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 800dffc:	683b      	ldr	r3, [r7, #0]
 800dffe:	68db      	ldr	r3, [r3, #12]
 800e000:	623b      	str	r3, [r7, #32]
          break;
 800e002:	e029      	b.n	800e058 <HAL_GPIO_Init+0x130>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 800e004:	683b      	ldr	r3, [r7, #0]
 800e006:	68db      	ldr	r3, [r3, #12]
 800e008:	3304      	adds	r3, #4
 800e00a:	623b      	str	r3, [r7, #32]
          break;
 800e00c:	e024      	b.n	800e058 <HAL_GPIO_Init+0x130>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 800e00e:	683b      	ldr	r3, [r7, #0]
 800e010:	68db      	ldr	r3, [r3, #12]
 800e012:	3308      	adds	r3, #8
 800e014:	623b      	str	r3, [r7, #32]
          break;
 800e016:	e01f      	b.n	800e058 <HAL_GPIO_Init+0x130>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 800e018:	683b      	ldr	r3, [r7, #0]
 800e01a:	68db      	ldr	r3, [r3, #12]
 800e01c:	330c      	adds	r3, #12
 800e01e:	623b      	str	r3, [r7, #32]
          break;
 800e020:	e01a      	b.n	800e058 <HAL_GPIO_Init+0x130>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 800e022:	683b      	ldr	r3, [r7, #0]
 800e024:	689b      	ldr	r3, [r3, #8]
 800e026:	2b00      	cmp	r3, #0
 800e028:	d102      	bne.n	800e030 <HAL_GPIO_Init+0x108>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 800e02a:	2304      	movs	r3, #4
 800e02c:	623b      	str	r3, [r7, #32]
          break;
 800e02e:	e013      	b.n	800e058 <HAL_GPIO_Init+0x130>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 800e030:	683b      	ldr	r3, [r7, #0]
 800e032:	689b      	ldr	r3, [r3, #8]
 800e034:	2b01      	cmp	r3, #1
 800e036:	d105      	bne.n	800e044 <HAL_GPIO_Init+0x11c>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 800e038:	2308      	movs	r3, #8
 800e03a:	623b      	str	r3, [r7, #32]
            GPIOx->BSRR = ioposition;
 800e03c:	687b      	ldr	r3, [r7, #4]
 800e03e:	69fa      	ldr	r2, [r7, #28]
 800e040:	611a      	str	r2, [r3, #16]
          break;
 800e042:	e009      	b.n	800e058 <HAL_GPIO_Init+0x130>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 800e044:	2308      	movs	r3, #8
 800e046:	623b      	str	r3, [r7, #32]
            GPIOx->BRR = ioposition;
 800e048:	687b      	ldr	r3, [r7, #4]
 800e04a:	69fa      	ldr	r2, [r7, #28]
 800e04c:	615a      	str	r2, [r3, #20]
          break;
 800e04e:	e003      	b.n	800e058 <HAL_GPIO_Init+0x130>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 800e050:	2300      	movs	r3, #0
 800e052:	623b      	str	r3, [r7, #32]
          break;
 800e054:	e000      	b.n	800e058 <HAL_GPIO_Init+0x130>
          break;
 800e056:	bf00      	nop
      }

      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 800e058:	69bb      	ldr	r3, [r7, #24]
 800e05a:	2bff      	cmp	r3, #255	@ 0xff
 800e05c:	d801      	bhi.n	800e062 <HAL_GPIO_Init+0x13a>
 800e05e:	687b      	ldr	r3, [r7, #4]
 800e060:	e001      	b.n	800e066 <HAL_GPIO_Init+0x13e>
 800e062:	687b      	ldr	r3, [r7, #4]
 800e064:	3304      	adds	r3, #4
 800e066:	617b      	str	r3, [r7, #20]
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 800e068:	69bb      	ldr	r3, [r7, #24]
 800e06a:	2bff      	cmp	r3, #255	@ 0xff
 800e06c:	d802      	bhi.n	800e074 <HAL_GPIO_Init+0x14c>
 800e06e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e070:	009b      	lsls	r3, r3, #2
 800e072:	e002      	b.n	800e07a <HAL_GPIO_Init+0x152>
 800e074:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e076:	3b08      	subs	r3, #8
 800e078:	009b      	lsls	r3, r3, #2
 800e07a:	613b      	str	r3, [r7, #16]

      /* Apply the new configuration of the pin to the register */
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 800e07c:	697b      	ldr	r3, [r7, #20]
 800e07e:	681a      	ldr	r2, [r3, #0]
 800e080:	210f      	movs	r1, #15
 800e082:	693b      	ldr	r3, [r7, #16]
 800e084:	fa01 f303 	lsl.w	r3, r1, r3
 800e088:	43db      	mvns	r3, r3
 800e08a:	401a      	ands	r2, r3
 800e08c:	6a39      	ldr	r1, [r7, #32]
 800e08e:	693b      	ldr	r3, [r7, #16]
 800e090:	fa01 f303 	lsl.w	r3, r1, r3
 800e094:	431a      	orrs	r2, r3
 800e096:	697b      	ldr	r3, [r7, #20]
 800e098:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800e09a:	683b      	ldr	r3, [r7, #0]
 800e09c:	685b      	ldr	r3, [r3, #4]
 800e09e:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800e0a2:	2b00      	cmp	r3, #0
 800e0a4:	f000 80b1 	beq.w	800e20a <HAL_GPIO_Init+0x2e2>
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 800e0a8:	4b4d      	ldr	r3, [pc, #308]	@ (800e1e0 <HAL_GPIO_Init+0x2b8>)
 800e0aa:	699b      	ldr	r3, [r3, #24]
 800e0ac:	4a4c      	ldr	r2, [pc, #304]	@ (800e1e0 <HAL_GPIO_Init+0x2b8>)
 800e0ae:	f043 0301 	orr.w	r3, r3, #1
 800e0b2:	6193      	str	r3, [r2, #24]
 800e0b4:	4b4a      	ldr	r3, [pc, #296]	@ (800e1e0 <HAL_GPIO_Init+0x2b8>)
 800e0b6:	699b      	ldr	r3, [r3, #24]
 800e0b8:	f003 0301 	and.w	r3, r3, #1
 800e0bc:	60bb      	str	r3, [r7, #8]
 800e0be:	68bb      	ldr	r3, [r7, #8]
        temp = AFIO->EXTICR[position >> 2u];
 800e0c0:	4a48      	ldr	r2, [pc, #288]	@ (800e1e4 <HAL_GPIO_Init+0x2bc>)
 800e0c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e0c4:	089b      	lsrs	r3, r3, #2
 800e0c6:	3302      	adds	r3, #2
 800e0c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e0cc:	60fb      	str	r3, [r7, #12]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 800e0ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e0d0:	f003 0303 	and.w	r3, r3, #3
 800e0d4:	009b      	lsls	r3, r3, #2
 800e0d6:	220f      	movs	r2, #15
 800e0d8:	fa02 f303 	lsl.w	r3, r2, r3
 800e0dc:	43db      	mvns	r3, r3
 800e0de:	68fa      	ldr	r2, [r7, #12]
 800e0e0:	4013      	ands	r3, r2
 800e0e2:	60fb      	str	r3, [r7, #12]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 800e0e4:	687b      	ldr	r3, [r7, #4]
 800e0e6:	4a40      	ldr	r2, [pc, #256]	@ (800e1e8 <HAL_GPIO_Init+0x2c0>)
 800e0e8:	4293      	cmp	r3, r2
 800e0ea:	d013      	beq.n	800e114 <HAL_GPIO_Init+0x1ec>
 800e0ec:	687b      	ldr	r3, [r7, #4]
 800e0ee:	4a3f      	ldr	r2, [pc, #252]	@ (800e1ec <HAL_GPIO_Init+0x2c4>)
 800e0f0:	4293      	cmp	r3, r2
 800e0f2:	d00d      	beq.n	800e110 <HAL_GPIO_Init+0x1e8>
 800e0f4:	687b      	ldr	r3, [r7, #4]
 800e0f6:	4a3e      	ldr	r2, [pc, #248]	@ (800e1f0 <HAL_GPIO_Init+0x2c8>)
 800e0f8:	4293      	cmp	r3, r2
 800e0fa:	d007      	beq.n	800e10c <HAL_GPIO_Init+0x1e4>
 800e0fc:	687b      	ldr	r3, [r7, #4]
 800e0fe:	4a3d      	ldr	r2, [pc, #244]	@ (800e1f4 <HAL_GPIO_Init+0x2cc>)
 800e100:	4293      	cmp	r3, r2
 800e102:	d101      	bne.n	800e108 <HAL_GPIO_Init+0x1e0>
 800e104:	2303      	movs	r3, #3
 800e106:	e006      	b.n	800e116 <HAL_GPIO_Init+0x1ee>
 800e108:	2304      	movs	r3, #4
 800e10a:	e004      	b.n	800e116 <HAL_GPIO_Init+0x1ee>
 800e10c:	2302      	movs	r3, #2
 800e10e:	e002      	b.n	800e116 <HAL_GPIO_Init+0x1ee>
 800e110:	2301      	movs	r3, #1
 800e112:	e000      	b.n	800e116 <HAL_GPIO_Init+0x1ee>
 800e114:	2300      	movs	r3, #0
 800e116:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e118:	f002 0203 	and.w	r2, r2, #3
 800e11c:	0092      	lsls	r2, r2, #2
 800e11e:	4093      	lsls	r3, r2
 800e120:	68fa      	ldr	r2, [r7, #12]
 800e122:	4313      	orrs	r3, r2
 800e124:	60fb      	str	r3, [r7, #12]
        AFIO->EXTICR[position >> 2u] = temp;
 800e126:	492f      	ldr	r1, [pc, #188]	@ (800e1e4 <HAL_GPIO_Init+0x2bc>)
 800e128:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e12a:	089b      	lsrs	r3, r3, #2
 800e12c:	3302      	adds	r3, #2
 800e12e:	68fa      	ldr	r2, [r7, #12]
 800e130:	f841 2023 	str.w	r2, [r1, r3, lsl #2]


        /* Enable or disable the rising trigger */
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800e134:	683b      	ldr	r3, [r7, #0]
 800e136:	685b      	ldr	r3, [r3, #4]
 800e138:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 800e13c:	2b00      	cmp	r3, #0
 800e13e:	d006      	beq.n	800e14e <HAL_GPIO_Init+0x226>
        {
          SET_BIT(EXTI->RTSR, iocurrent);
 800e140:	4b2d      	ldr	r3, [pc, #180]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e142:	689a      	ldr	r2, [r3, #8]
 800e144:	492c      	ldr	r1, [pc, #176]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e146:	69bb      	ldr	r3, [r7, #24]
 800e148:	4313      	orrs	r3, r2
 800e14a:	608b      	str	r3, [r1, #8]
 800e14c:	e006      	b.n	800e15c <HAL_GPIO_Init+0x234>
        }
        else
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 800e14e:	4b2a      	ldr	r3, [pc, #168]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e150:	689a      	ldr	r2, [r3, #8]
 800e152:	69bb      	ldr	r3, [r7, #24]
 800e154:	43db      	mvns	r3, r3
 800e156:	4928      	ldr	r1, [pc, #160]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e158:	4013      	ands	r3, r2
 800e15a:	608b      	str	r3, [r1, #8]
        }

        /* Enable or disable the falling trigger */
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800e15c:	683b      	ldr	r3, [r7, #0]
 800e15e:	685b      	ldr	r3, [r3, #4]
 800e160:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800e164:	2b00      	cmp	r3, #0
 800e166:	d006      	beq.n	800e176 <HAL_GPIO_Init+0x24e>
        {
          SET_BIT(EXTI->FTSR, iocurrent);
 800e168:	4b23      	ldr	r3, [pc, #140]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e16a:	68da      	ldr	r2, [r3, #12]
 800e16c:	4922      	ldr	r1, [pc, #136]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e16e:	69bb      	ldr	r3, [r7, #24]
 800e170:	4313      	orrs	r3, r2
 800e172:	60cb      	str	r3, [r1, #12]
 800e174:	e006      	b.n	800e184 <HAL_GPIO_Init+0x25c>
        }
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 800e176:	4b20      	ldr	r3, [pc, #128]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e178:	68da      	ldr	r2, [r3, #12]
 800e17a:	69bb      	ldr	r3, [r7, #24]
 800e17c:	43db      	mvns	r3, r3
 800e17e:	491e      	ldr	r1, [pc, #120]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e180:	4013      	ands	r3, r2
 800e182:	60cb      	str	r3, [r1, #12]
        }

        /* Configure the event mask */
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800e184:	683b      	ldr	r3, [r7, #0]
 800e186:	685b      	ldr	r3, [r3, #4]
 800e188:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800e18c:	2b00      	cmp	r3, #0
 800e18e:	d006      	beq.n	800e19e <HAL_GPIO_Init+0x276>
        {
          SET_BIT(EXTI->EMR, iocurrent);
 800e190:	4b19      	ldr	r3, [pc, #100]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e192:	685a      	ldr	r2, [r3, #4]
 800e194:	4918      	ldr	r1, [pc, #96]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e196:	69bb      	ldr	r3, [r7, #24]
 800e198:	4313      	orrs	r3, r2
 800e19a:	604b      	str	r3, [r1, #4]
 800e19c:	e006      	b.n	800e1ac <HAL_GPIO_Init+0x284>
        }
        else
        {
          CLEAR_BIT(EXTI->EMR, iocurrent);
 800e19e:	4b16      	ldr	r3, [pc, #88]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e1a0:	685a      	ldr	r2, [r3, #4]
 800e1a2:	69bb      	ldr	r3, [r7, #24]
 800e1a4:	43db      	mvns	r3, r3
 800e1a6:	4914      	ldr	r1, [pc, #80]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e1a8:	4013      	ands	r3, r2
 800e1aa:	604b      	str	r3, [r1, #4]
        }

        /* Configure the interrupt mask */
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800e1ac:	683b      	ldr	r3, [r7, #0]
 800e1ae:	685b      	ldr	r3, [r3, #4]
 800e1b0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800e1b4:	2b00      	cmp	r3, #0
 800e1b6:	d021      	beq.n	800e1fc <HAL_GPIO_Init+0x2d4>
        {
          SET_BIT(EXTI->IMR, iocurrent);
 800e1b8:	4b0f      	ldr	r3, [pc, #60]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e1ba:	681a      	ldr	r2, [r3, #0]
 800e1bc:	490e      	ldr	r1, [pc, #56]	@ (800e1f8 <HAL_GPIO_Init+0x2d0>)
 800e1be:	69bb      	ldr	r3, [r7, #24]
 800e1c0:	4313      	orrs	r3, r2
 800e1c2:	600b      	str	r3, [r1, #0]
 800e1c4:	e021      	b.n	800e20a <HAL_GPIO_Init+0x2e2>
 800e1c6:	bf00      	nop
 800e1c8:	10320000 	.word	0x10320000
 800e1cc:	10310000 	.word	0x10310000
 800e1d0:	10220000 	.word	0x10220000
 800e1d4:	10210000 	.word	0x10210000
 800e1d8:	10120000 	.word	0x10120000
 800e1dc:	10110000 	.word	0x10110000
 800e1e0:	40021000 	.word	0x40021000
 800e1e4:	40010000 	.word	0x40010000
 800e1e8:	40010800 	.word	0x40010800
 800e1ec:	40010c00 	.word	0x40010c00
 800e1f0:	40011000 	.word	0x40011000
 800e1f4:	40011400 	.word	0x40011400
 800e1f8:	40010400 	.word	0x40010400
        }
        else
        {
          CLEAR_BIT(EXTI->IMR, iocurrent);
 800e1fc:	4b0b      	ldr	r3, [pc, #44]	@ (800e22c <HAL_GPIO_Init+0x304>)
 800e1fe:	681a      	ldr	r2, [r3, #0]
 800e200:	69bb      	ldr	r3, [r7, #24]
 800e202:	43db      	mvns	r3, r3
 800e204:	4909      	ldr	r1, [pc, #36]	@ (800e22c <HAL_GPIO_Init+0x304>)
 800e206:	4013      	ands	r3, r2
 800e208:	600b      	str	r3, [r1, #0]
        }
      }
    }

	position++;
 800e20a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e20c:	3301      	adds	r3, #1
 800e20e:	627b      	str	r3, [r7, #36]	@ 0x24
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800e210:	683b      	ldr	r3, [r7, #0]
 800e212:	681a      	ldr	r2, [r3, #0]
 800e214:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e216:	fa22 f303 	lsr.w	r3, r2, r3
 800e21a:	2b00      	cmp	r3, #0
 800e21c:	f47f ae8e 	bne.w	800df3c <HAL_GPIO_Init+0x14>
  }
}
 800e220:	bf00      	nop
 800e222:	bf00      	nop
 800e224:	372c      	adds	r7, #44	@ 0x2c
 800e226:	46bd      	mov	sp, r7
 800e228:	bc80      	pop	{r7}
 800e22a:	4770      	bx	lr
 800e22c:	40010400 	.word	0x40010400

0800e230 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800e230:	b480      	push	{r7}
 800e232:	b083      	sub	sp, #12
 800e234:	af00      	add	r7, sp, #0
 800e236:	6078      	str	r0, [r7, #4]
 800e238:	460b      	mov	r3, r1
 800e23a:	807b      	strh	r3, [r7, #2]
 800e23c:	4613      	mov	r3, r2
 800e23e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800e240:	787b      	ldrb	r3, [r7, #1]
 800e242:	2b00      	cmp	r3, #0
 800e244:	d003      	beq.n	800e24e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 800e246:	887a      	ldrh	r2, [r7, #2]
 800e248:	687b      	ldr	r3, [r7, #4]
 800e24a:	611a      	str	r2, [r3, #16]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
  }
}
 800e24c:	e003      	b.n	800e256 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
 800e24e:	887b      	ldrh	r3, [r7, #2]
 800e250:	041a      	lsls	r2, r3, #16
 800e252:	687b      	ldr	r3, [r7, #4]
 800e254:	611a      	str	r2, [r3, #16]
}
 800e256:	bf00      	nop
 800e258:	370c      	adds	r7, #12
 800e25a:	46bd      	mov	sp, r7
 800e25c:	bc80      	pop	{r7}
 800e25e:	4770      	bx	lr

0800e260 <HAL_GPIO_TogglePin>:
  * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 800e260:	b480      	push	{r7}
 800e262:	b085      	sub	sp, #20
 800e264:	af00      	add	r7, sp, #0
 800e266:	6078      	str	r0, [r7, #4]
 800e268:	460b      	mov	r3, r1
 800e26a:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 800e26c:	687b      	ldr	r3, [r7, #4]
 800e26e:	68db      	ldr	r3, [r3, #12]
 800e270:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 800e272:	887a      	ldrh	r2, [r7, #2]
 800e274:	68fb      	ldr	r3, [r7, #12]
 800e276:	4013      	ands	r3, r2
 800e278:	041a      	lsls	r2, r3, #16
 800e27a:	68fb      	ldr	r3, [r7, #12]
 800e27c:	43d9      	mvns	r1, r3
 800e27e:	887b      	ldrh	r3, [r7, #2]
 800e280:	400b      	ands	r3, r1
 800e282:	431a      	orrs	r2, r3
 800e284:	687b      	ldr	r3, [r7, #4]
 800e286:	611a      	str	r2, [r3, #16]
}
 800e288:	bf00      	nop
 800e28a:	3714      	adds	r7, #20
 800e28c:	46bd      	mov	sp, r7
 800e28e:	bc80      	pop	{r7}
 800e290:	4770      	bx	lr
	...

0800e294 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800e294:	b580      	push	{r7, lr}
 800e296:	b086      	sub	sp, #24
 800e298:	af00      	add	r7, sp, #0
 800e29a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800e29c:	687b      	ldr	r3, [r7, #4]
 800e29e:	2b00      	cmp	r3, #0
 800e2a0:	d101      	bne.n	800e2a6 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 800e2a2:	2301      	movs	r3, #1
 800e2a4:	e272      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800e2a6:	687b      	ldr	r3, [r7, #4]
 800e2a8:	681b      	ldr	r3, [r3, #0]
 800e2aa:	f003 0301 	and.w	r3, r3, #1
 800e2ae:	2b00      	cmp	r3, #0
 800e2b0:	f000 8087 	beq.w	800e3c2 <HAL_RCC_OscConfig+0x12e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 800e2b4:	4b92      	ldr	r3, [pc, #584]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e2b6:	685b      	ldr	r3, [r3, #4]
 800e2b8:	f003 030c 	and.w	r3, r3, #12
 800e2bc:	2b04      	cmp	r3, #4
 800e2be:	d00c      	beq.n	800e2da <HAL_RCC_OscConfig+0x46>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 800e2c0:	4b8f      	ldr	r3, [pc, #572]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e2c2:	685b      	ldr	r3, [r3, #4]
 800e2c4:	f003 030c 	and.w	r3, r3, #12
 800e2c8:	2b08      	cmp	r3, #8
 800e2ca:	d112      	bne.n	800e2f2 <HAL_RCC_OscConfig+0x5e>
 800e2cc:	4b8c      	ldr	r3, [pc, #560]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e2ce:	685b      	ldr	r3, [r3, #4]
 800e2d0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800e2d4:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800e2d8:	d10b      	bne.n	800e2f2 <HAL_RCC_OscConfig+0x5e>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800e2da:	4b89      	ldr	r3, [pc, #548]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e2dc:	681b      	ldr	r3, [r3, #0]
 800e2de:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800e2e2:	2b00      	cmp	r3, #0
 800e2e4:	d06c      	beq.n	800e3c0 <HAL_RCC_OscConfig+0x12c>
 800e2e6:	687b      	ldr	r3, [r7, #4]
 800e2e8:	685b      	ldr	r3, [r3, #4]
 800e2ea:	2b00      	cmp	r3, #0
 800e2ec:	d168      	bne.n	800e3c0 <HAL_RCC_OscConfig+0x12c>
      {
        return HAL_ERROR;
 800e2ee:	2301      	movs	r3, #1
 800e2f0:	e24c      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800e2f2:	687b      	ldr	r3, [r7, #4]
 800e2f4:	685b      	ldr	r3, [r3, #4]
 800e2f6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800e2fa:	d106      	bne.n	800e30a <HAL_RCC_OscConfig+0x76>
 800e2fc:	4b80      	ldr	r3, [pc, #512]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e2fe:	681b      	ldr	r3, [r3, #0]
 800e300:	4a7f      	ldr	r2, [pc, #508]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e302:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800e306:	6013      	str	r3, [r2, #0]
 800e308:	e02e      	b.n	800e368 <HAL_RCC_OscConfig+0xd4>
 800e30a:	687b      	ldr	r3, [r7, #4]
 800e30c:	685b      	ldr	r3, [r3, #4]
 800e30e:	2b00      	cmp	r3, #0
 800e310:	d10c      	bne.n	800e32c <HAL_RCC_OscConfig+0x98>
 800e312:	4b7b      	ldr	r3, [pc, #492]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e314:	681b      	ldr	r3, [r3, #0]
 800e316:	4a7a      	ldr	r2, [pc, #488]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e318:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800e31c:	6013      	str	r3, [r2, #0]
 800e31e:	4b78      	ldr	r3, [pc, #480]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e320:	681b      	ldr	r3, [r3, #0]
 800e322:	4a77      	ldr	r2, [pc, #476]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e324:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800e328:	6013      	str	r3, [r2, #0]
 800e32a:	e01d      	b.n	800e368 <HAL_RCC_OscConfig+0xd4>
 800e32c:	687b      	ldr	r3, [r7, #4]
 800e32e:	685b      	ldr	r3, [r3, #4]
 800e330:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800e334:	d10c      	bne.n	800e350 <HAL_RCC_OscConfig+0xbc>
 800e336:	4b72      	ldr	r3, [pc, #456]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e338:	681b      	ldr	r3, [r3, #0]
 800e33a:	4a71      	ldr	r2, [pc, #452]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e33c:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800e340:	6013      	str	r3, [r2, #0]
 800e342:	4b6f      	ldr	r3, [pc, #444]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e344:	681b      	ldr	r3, [r3, #0]
 800e346:	4a6e      	ldr	r2, [pc, #440]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e348:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800e34c:	6013      	str	r3, [r2, #0]
 800e34e:	e00b      	b.n	800e368 <HAL_RCC_OscConfig+0xd4>
 800e350:	4b6b      	ldr	r3, [pc, #428]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e352:	681b      	ldr	r3, [r3, #0]
 800e354:	4a6a      	ldr	r2, [pc, #424]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e356:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800e35a:	6013      	str	r3, [r2, #0]
 800e35c:	4b68      	ldr	r3, [pc, #416]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e35e:	681b      	ldr	r3, [r3, #0]
 800e360:	4a67      	ldr	r2, [pc, #412]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e362:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800e366:	6013      	str	r3, [r2, #0]


      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800e368:	687b      	ldr	r3, [r7, #4]
 800e36a:	685b      	ldr	r3, [r3, #4]
 800e36c:	2b00      	cmp	r3, #0
 800e36e:	d013      	beq.n	800e398 <HAL_RCC_OscConfig+0x104>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800e370:	f7fe ff6a 	bl	800d248 <HAL_GetTick>
 800e374:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800e376:	e008      	b.n	800e38a <HAL_RCC_OscConfig+0xf6>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800e378:	f7fe ff66 	bl	800d248 <HAL_GetTick>
 800e37c:	4602      	mov	r2, r0
 800e37e:	693b      	ldr	r3, [r7, #16]
 800e380:	1ad3      	subs	r3, r2, r3
 800e382:	2b64      	cmp	r3, #100	@ 0x64
 800e384:	d901      	bls.n	800e38a <HAL_RCC_OscConfig+0xf6>
          {
            return HAL_TIMEOUT;
 800e386:	2303      	movs	r3, #3
 800e388:	e200      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800e38a:	4b5d      	ldr	r3, [pc, #372]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e38c:	681b      	ldr	r3, [r3, #0]
 800e38e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800e392:	2b00      	cmp	r3, #0
 800e394:	d0f0      	beq.n	800e378 <HAL_RCC_OscConfig+0xe4>
 800e396:	e014      	b.n	800e3c2 <HAL_RCC_OscConfig+0x12e>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800e398:	f7fe ff56 	bl	800d248 <HAL_GetTick>
 800e39c:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800e39e:	e008      	b.n	800e3b2 <HAL_RCC_OscConfig+0x11e>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800e3a0:	f7fe ff52 	bl	800d248 <HAL_GetTick>
 800e3a4:	4602      	mov	r2, r0
 800e3a6:	693b      	ldr	r3, [r7, #16]
 800e3a8:	1ad3      	subs	r3, r2, r3
 800e3aa:	2b64      	cmp	r3, #100	@ 0x64
 800e3ac:	d901      	bls.n	800e3b2 <HAL_RCC_OscConfig+0x11e>
          {
            return HAL_TIMEOUT;
 800e3ae:	2303      	movs	r3, #3
 800e3b0:	e1ec      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800e3b2:	4b53      	ldr	r3, [pc, #332]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e3b4:	681b      	ldr	r3, [r3, #0]
 800e3b6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800e3ba:	2b00      	cmp	r3, #0
 800e3bc:	d1f0      	bne.n	800e3a0 <HAL_RCC_OscConfig+0x10c>
 800e3be:	e000      	b.n	800e3c2 <HAL_RCC_OscConfig+0x12e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800e3c0:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800e3c2:	687b      	ldr	r3, [r7, #4]
 800e3c4:	681b      	ldr	r3, [r3, #0]
 800e3c6:	f003 0302 	and.w	r3, r3, #2
 800e3ca:	2b00      	cmp	r3, #0
 800e3cc:	d063      	beq.n	800e496 <HAL_RCC_OscConfig+0x202>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 800e3ce:	4b4c      	ldr	r3, [pc, #304]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e3d0:	685b      	ldr	r3, [r3, #4]
 800e3d2:	f003 030c 	and.w	r3, r3, #12
 800e3d6:	2b00      	cmp	r3, #0
 800e3d8:	d00b      	beq.n	800e3f2 <HAL_RCC_OscConfig+0x15e>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 800e3da:	4b49      	ldr	r3, [pc, #292]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e3dc:	685b      	ldr	r3, [r3, #4]
 800e3de:	f003 030c 	and.w	r3, r3, #12
 800e3e2:	2b08      	cmp	r3, #8
 800e3e4:	d11c      	bne.n	800e420 <HAL_RCC_OscConfig+0x18c>
 800e3e6:	4b46      	ldr	r3, [pc, #280]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e3e8:	685b      	ldr	r3, [r3, #4]
 800e3ea:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800e3ee:	2b00      	cmp	r3, #0
 800e3f0:	d116      	bne.n	800e420 <HAL_RCC_OscConfig+0x18c>
    {
      /* When HSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800e3f2:	4b43      	ldr	r3, [pc, #268]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e3f4:	681b      	ldr	r3, [r3, #0]
 800e3f6:	f003 0302 	and.w	r3, r3, #2
 800e3fa:	2b00      	cmp	r3, #0
 800e3fc:	d005      	beq.n	800e40a <HAL_RCC_OscConfig+0x176>
 800e3fe:	687b      	ldr	r3, [r7, #4]
 800e400:	691b      	ldr	r3, [r3, #16]
 800e402:	2b01      	cmp	r3, #1
 800e404:	d001      	beq.n	800e40a <HAL_RCC_OscConfig+0x176>
      {
        return HAL_ERROR;
 800e406:	2301      	movs	r3, #1
 800e408:	e1c0      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800e40a:	4b3d      	ldr	r3, [pc, #244]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e40c:	681b      	ldr	r3, [r3, #0]
 800e40e:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 800e412:	687b      	ldr	r3, [r7, #4]
 800e414:	695b      	ldr	r3, [r3, #20]
 800e416:	00db      	lsls	r3, r3, #3
 800e418:	4939      	ldr	r1, [pc, #228]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e41a:	4313      	orrs	r3, r2
 800e41c:	600b      	str	r3, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800e41e:	e03a      	b.n	800e496 <HAL_RCC_OscConfig+0x202>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800e420:	687b      	ldr	r3, [r7, #4]
 800e422:	691b      	ldr	r3, [r3, #16]
 800e424:	2b00      	cmp	r3, #0
 800e426:	d020      	beq.n	800e46a <HAL_RCC_OscConfig+0x1d6>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800e428:	4b36      	ldr	r3, [pc, #216]	@ (800e504 <HAL_RCC_OscConfig+0x270>)
 800e42a:	2201      	movs	r2, #1
 800e42c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800e42e:	f7fe ff0b 	bl	800d248 <HAL_GetTick>
 800e432:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800e434:	e008      	b.n	800e448 <HAL_RCC_OscConfig+0x1b4>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800e436:	f7fe ff07 	bl	800d248 <HAL_GetTick>
 800e43a:	4602      	mov	r2, r0
 800e43c:	693b      	ldr	r3, [r7, #16]
 800e43e:	1ad3      	subs	r3, r2, r3
 800e440:	2b02      	cmp	r3, #2
 800e442:	d901      	bls.n	800e448 <HAL_RCC_OscConfig+0x1b4>
          {
            return HAL_TIMEOUT;
 800e444:	2303      	movs	r3, #3
 800e446:	e1a1      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800e448:	4b2d      	ldr	r3, [pc, #180]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e44a:	681b      	ldr	r3, [r3, #0]
 800e44c:	f003 0302 	and.w	r3, r3, #2
 800e450:	2b00      	cmp	r3, #0
 800e452:	d0f0      	beq.n	800e436 <HAL_RCC_OscConfig+0x1a2>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800e454:	4b2a      	ldr	r3, [pc, #168]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e456:	681b      	ldr	r3, [r3, #0]
 800e458:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 800e45c:	687b      	ldr	r3, [r7, #4]
 800e45e:	695b      	ldr	r3, [r3, #20]
 800e460:	00db      	lsls	r3, r3, #3
 800e462:	4927      	ldr	r1, [pc, #156]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e464:	4313      	orrs	r3, r2
 800e466:	600b      	str	r3, [r1, #0]
 800e468:	e015      	b.n	800e496 <HAL_RCC_OscConfig+0x202>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800e46a:	4b26      	ldr	r3, [pc, #152]	@ (800e504 <HAL_RCC_OscConfig+0x270>)
 800e46c:	2200      	movs	r2, #0
 800e46e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800e470:	f7fe feea 	bl	800d248 <HAL_GetTick>
 800e474:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800e476:	e008      	b.n	800e48a <HAL_RCC_OscConfig+0x1f6>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800e478:	f7fe fee6 	bl	800d248 <HAL_GetTick>
 800e47c:	4602      	mov	r2, r0
 800e47e:	693b      	ldr	r3, [r7, #16]
 800e480:	1ad3      	subs	r3, r2, r3
 800e482:	2b02      	cmp	r3, #2
 800e484:	d901      	bls.n	800e48a <HAL_RCC_OscConfig+0x1f6>
          {
            return HAL_TIMEOUT;
 800e486:	2303      	movs	r3, #3
 800e488:	e180      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800e48a:	4b1d      	ldr	r3, [pc, #116]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e48c:	681b      	ldr	r3, [r3, #0]
 800e48e:	f003 0302 	and.w	r3, r3, #2
 800e492:	2b00      	cmp	r3, #0
 800e494:	d1f0      	bne.n	800e478 <HAL_RCC_OscConfig+0x1e4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800e496:	687b      	ldr	r3, [r7, #4]
 800e498:	681b      	ldr	r3, [r3, #0]
 800e49a:	f003 0308 	and.w	r3, r3, #8
 800e49e:	2b00      	cmp	r3, #0
 800e4a0:	d03a      	beq.n	800e518 <HAL_RCC_OscConfig+0x284>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800e4a2:	687b      	ldr	r3, [r7, #4]
 800e4a4:	699b      	ldr	r3, [r3, #24]
 800e4a6:	2b00      	cmp	r3, #0
 800e4a8:	d019      	beq.n	800e4de <HAL_RCC_OscConfig+0x24a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800e4aa:	4b17      	ldr	r3, [pc, #92]	@ (800e508 <HAL_RCC_OscConfig+0x274>)
 800e4ac:	2201      	movs	r2, #1
 800e4ae:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800e4b0:	f7fe feca 	bl	800d248 <HAL_GetTick>
 800e4b4:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800e4b6:	e008      	b.n	800e4ca <HAL_RCC_OscConfig+0x236>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800e4b8:	f7fe fec6 	bl	800d248 <HAL_GetTick>
 800e4bc:	4602      	mov	r2, r0
 800e4be:	693b      	ldr	r3, [r7, #16]
 800e4c0:	1ad3      	subs	r3, r2, r3
 800e4c2:	2b02      	cmp	r3, #2
 800e4c4:	d901      	bls.n	800e4ca <HAL_RCC_OscConfig+0x236>
        {
          return HAL_TIMEOUT;
 800e4c6:	2303      	movs	r3, #3
 800e4c8:	e160      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800e4ca:	4b0d      	ldr	r3, [pc, #52]	@ (800e500 <HAL_RCC_OscConfig+0x26c>)
 800e4cc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800e4ce:	f003 0302 	and.w	r3, r3, #2
 800e4d2:	2b00      	cmp	r3, #0
 800e4d4:	d0f0      	beq.n	800e4b8 <HAL_RCC_OscConfig+0x224>
        }
      }
      /*  To have a fully stabilized clock in the specified range, a software delay of 1ms
          should be added.*/
      RCC_Delay(1);
 800e4d6:	2001      	movs	r0, #1
 800e4d8:	f000 face 	bl	800ea78 <RCC_Delay>
 800e4dc:	e01c      	b.n	800e518 <HAL_RCC_OscConfig+0x284>
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800e4de:	4b0a      	ldr	r3, [pc, #40]	@ (800e508 <HAL_RCC_OscConfig+0x274>)
 800e4e0:	2200      	movs	r2, #0
 800e4e2:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800e4e4:	f7fe feb0 	bl	800d248 <HAL_GetTick>
 800e4e8:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is disabled */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800e4ea:	e00f      	b.n	800e50c <HAL_RCC_OscConfig+0x278>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800e4ec:	f7fe feac 	bl	800d248 <HAL_GetTick>
 800e4f0:	4602      	mov	r2, r0
 800e4f2:	693b      	ldr	r3, [r7, #16]
 800e4f4:	1ad3      	subs	r3, r2, r3
 800e4f6:	2b02      	cmp	r3, #2
 800e4f8:	d908      	bls.n	800e50c <HAL_RCC_OscConfig+0x278>
        {
          return HAL_TIMEOUT;
 800e4fa:	2303      	movs	r3, #3
 800e4fc:	e146      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
 800e4fe:	bf00      	nop
 800e500:	40021000 	.word	0x40021000
 800e504:	42420000 	.word	0x42420000
 800e508:	42420480 	.word	0x42420480
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800e50c:	4b92      	ldr	r3, [pc, #584]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e50e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800e510:	f003 0302 	and.w	r3, r3, #2
 800e514:	2b00      	cmp	r3, #0
 800e516:	d1e9      	bne.n	800e4ec <HAL_RCC_OscConfig+0x258>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800e518:	687b      	ldr	r3, [r7, #4]
 800e51a:	681b      	ldr	r3, [r3, #0]
 800e51c:	f003 0304 	and.w	r3, r3, #4
 800e520:	2b00      	cmp	r3, #0
 800e522:	f000 80a6 	beq.w	800e672 <HAL_RCC_OscConfig+0x3de>
  {
    FlagStatus       pwrclkchanged = RESET;
 800e526:	2300      	movs	r3, #0
 800e528:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 800e52a:	4b8b      	ldr	r3, [pc, #556]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e52c:	69db      	ldr	r3, [r3, #28]
 800e52e:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800e532:	2b00      	cmp	r3, #0
 800e534:	d10d      	bne.n	800e552 <HAL_RCC_OscConfig+0x2be>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800e536:	4b88      	ldr	r3, [pc, #544]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e538:	69db      	ldr	r3, [r3, #28]
 800e53a:	4a87      	ldr	r2, [pc, #540]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e53c:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800e540:	61d3      	str	r3, [r2, #28]
 800e542:	4b85      	ldr	r3, [pc, #532]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e544:	69db      	ldr	r3, [r3, #28]
 800e546:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800e54a:	60bb      	str	r3, [r7, #8]
 800e54c:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800e54e:	2301      	movs	r3, #1
 800e550:	75fb      	strb	r3, [r7, #23]
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800e552:	4b82      	ldr	r3, [pc, #520]	@ (800e75c <HAL_RCC_OscConfig+0x4c8>)
 800e554:	681b      	ldr	r3, [r3, #0]
 800e556:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800e55a:	2b00      	cmp	r3, #0
 800e55c:	d118      	bne.n	800e590 <HAL_RCC_OscConfig+0x2fc>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800e55e:	4b7f      	ldr	r3, [pc, #508]	@ (800e75c <HAL_RCC_OscConfig+0x4c8>)
 800e560:	681b      	ldr	r3, [r3, #0]
 800e562:	4a7e      	ldr	r2, [pc, #504]	@ (800e75c <HAL_RCC_OscConfig+0x4c8>)
 800e564:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800e568:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800e56a:	f7fe fe6d 	bl	800d248 <HAL_GetTick>
 800e56e:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800e570:	e008      	b.n	800e584 <HAL_RCC_OscConfig+0x2f0>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800e572:	f7fe fe69 	bl	800d248 <HAL_GetTick>
 800e576:	4602      	mov	r2, r0
 800e578:	693b      	ldr	r3, [r7, #16]
 800e57a:	1ad3      	subs	r3, r2, r3
 800e57c:	2b64      	cmp	r3, #100	@ 0x64
 800e57e:	d901      	bls.n	800e584 <HAL_RCC_OscConfig+0x2f0>
        {
          return HAL_TIMEOUT;
 800e580:	2303      	movs	r3, #3
 800e582:	e103      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800e584:	4b75      	ldr	r3, [pc, #468]	@ (800e75c <HAL_RCC_OscConfig+0x4c8>)
 800e586:	681b      	ldr	r3, [r3, #0]
 800e588:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800e58c:	2b00      	cmp	r3, #0
 800e58e:	d0f0      	beq.n	800e572 <HAL_RCC_OscConfig+0x2de>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800e590:	687b      	ldr	r3, [r7, #4]
 800e592:	68db      	ldr	r3, [r3, #12]
 800e594:	2b01      	cmp	r3, #1
 800e596:	d106      	bne.n	800e5a6 <HAL_RCC_OscConfig+0x312>
 800e598:	4b6f      	ldr	r3, [pc, #444]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e59a:	6a1b      	ldr	r3, [r3, #32]
 800e59c:	4a6e      	ldr	r2, [pc, #440]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e59e:	f043 0301 	orr.w	r3, r3, #1
 800e5a2:	6213      	str	r3, [r2, #32]
 800e5a4:	e02d      	b.n	800e602 <HAL_RCC_OscConfig+0x36e>
 800e5a6:	687b      	ldr	r3, [r7, #4]
 800e5a8:	68db      	ldr	r3, [r3, #12]
 800e5aa:	2b00      	cmp	r3, #0
 800e5ac:	d10c      	bne.n	800e5c8 <HAL_RCC_OscConfig+0x334>
 800e5ae:	4b6a      	ldr	r3, [pc, #424]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5b0:	6a1b      	ldr	r3, [r3, #32]
 800e5b2:	4a69      	ldr	r2, [pc, #420]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5b4:	f023 0301 	bic.w	r3, r3, #1
 800e5b8:	6213      	str	r3, [r2, #32]
 800e5ba:	4b67      	ldr	r3, [pc, #412]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5bc:	6a1b      	ldr	r3, [r3, #32]
 800e5be:	4a66      	ldr	r2, [pc, #408]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5c0:	f023 0304 	bic.w	r3, r3, #4
 800e5c4:	6213      	str	r3, [r2, #32]
 800e5c6:	e01c      	b.n	800e602 <HAL_RCC_OscConfig+0x36e>
 800e5c8:	687b      	ldr	r3, [r7, #4]
 800e5ca:	68db      	ldr	r3, [r3, #12]
 800e5cc:	2b05      	cmp	r3, #5
 800e5ce:	d10c      	bne.n	800e5ea <HAL_RCC_OscConfig+0x356>
 800e5d0:	4b61      	ldr	r3, [pc, #388]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5d2:	6a1b      	ldr	r3, [r3, #32]
 800e5d4:	4a60      	ldr	r2, [pc, #384]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5d6:	f043 0304 	orr.w	r3, r3, #4
 800e5da:	6213      	str	r3, [r2, #32]
 800e5dc:	4b5e      	ldr	r3, [pc, #376]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5de:	6a1b      	ldr	r3, [r3, #32]
 800e5e0:	4a5d      	ldr	r2, [pc, #372]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5e2:	f043 0301 	orr.w	r3, r3, #1
 800e5e6:	6213      	str	r3, [r2, #32]
 800e5e8:	e00b      	b.n	800e602 <HAL_RCC_OscConfig+0x36e>
 800e5ea:	4b5b      	ldr	r3, [pc, #364]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5ec:	6a1b      	ldr	r3, [r3, #32]
 800e5ee:	4a5a      	ldr	r2, [pc, #360]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5f0:	f023 0301 	bic.w	r3, r3, #1
 800e5f4:	6213      	str	r3, [r2, #32]
 800e5f6:	4b58      	ldr	r3, [pc, #352]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5f8:	6a1b      	ldr	r3, [r3, #32]
 800e5fa:	4a57      	ldr	r2, [pc, #348]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e5fc:	f023 0304 	bic.w	r3, r3, #4
 800e600:	6213      	str	r3, [r2, #32]
    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800e602:	687b      	ldr	r3, [r7, #4]
 800e604:	68db      	ldr	r3, [r3, #12]
 800e606:	2b00      	cmp	r3, #0
 800e608:	d015      	beq.n	800e636 <HAL_RCC_OscConfig+0x3a2>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800e60a:	f7fe fe1d 	bl	800d248 <HAL_GetTick>
 800e60e:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800e610:	e00a      	b.n	800e628 <HAL_RCC_OscConfig+0x394>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e612:	f7fe fe19 	bl	800d248 <HAL_GetTick>
 800e616:	4602      	mov	r2, r0
 800e618:	693b      	ldr	r3, [r7, #16]
 800e61a:	1ad3      	subs	r3, r2, r3
 800e61c:	f241 3288 	movw	r2, #5000	@ 0x1388
 800e620:	4293      	cmp	r3, r2
 800e622:	d901      	bls.n	800e628 <HAL_RCC_OscConfig+0x394>
        {
          return HAL_TIMEOUT;
 800e624:	2303      	movs	r3, #3
 800e626:	e0b1      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800e628:	4b4b      	ldr	r3, [pc, #300]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e62a:	6a1b      	ldr	r3, [r3, #32]
 800e62c:	f003 0302 	and.w	r3, r3, #2
 800e630:	2b00      	cmp	r3, #0
 800e632:	d0ee      	beq.n	800e612 <HAL_RCC_OscConfig+0x37e>
 800e634:	e014      	b.n	800e660 <HAL_RCC_OscConfig+0x3cc>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800e636:	f7fe fe07 	bl	800d248 <HAL_GetTick>
 800e63a:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is disabled */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800e63c:	e00a      	b.n	800e654 <HAL_RCC_OscConfig+0x3c0>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800e63e:	f7fe fe03 	bl	800d248 <HAL_GetTick>
 800e642:	4602      	mov	r2, r0
 800e644:	693b      	ldr	r3, [r7, #16]
 800e646:	1ad3      	subs	r3, r2, r3
 800e648:	f241 3288 	movw	r2, #5000	@ 0x1388
 800e64c:	4293      	cmp	r3, r2
 800e64e:	d901      	bls.n	800e654 <HAL_RCC_OscConfig+0x3c0>
        {
          return HAL_TIMEOUT;
 800e650:	2303      	movs	r3, #3
 800e652:	e09b      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800e654:	4b40      	ldr	r3, [pc, #256]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e656:	6a1b      	ldr	r3, [r3, #32]
 800e658:	f003 0302 	and.w	r3, r3, #2
 800e65c:	2b00      	cmp	r3, #0
 800e65e:	d1ee      	bne.n	800e63e <HAL_RCC_OscConfig+0x3aa>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if (pwrclkchanged == SET)
 800e660:	7dfb      	ldrb	r3, [r7, #23]
 800e662:	2b01      	cmp	r3, #1
 800e664:	d105      	bne.n	800e672 <HAL_RCC_OscConfig+0x3de>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800e666:	4b3c      	ldr	r3, [pc, #240]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e668:	69db      	ldr	r3, [r3, #28]
 800e66a:	4a3b      	ldr	r2, [pc, #236]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e66c:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 800e670:	61d3      	str	r3, [r2, #28]

#endif /* RCC_CR_PLL2ON */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800e672:	687b      	ldr	r3, [r7, #4]
 800e674:	69db      	ldr	r3, [r3, #28]
 800e676:	2b00      	cmp	r3, #0
 800e678:	f000 8087 	beq.w	800e78a <HAL_RCC_OscConfig+0x4f6>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800e67c:	4b36      	ldr	r3, [pc, #216]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e67e:	685b      	ldr	r3, [r3, #4]
 800e680:	f003 030c 	and.w	r3, r3, #12
 800e684:	2b08      	cmp	r3, #8
 800e686:	d061      	beq.n	800e74c <HAL_RCC_OscConfig+0x4b8>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800e688:	687b      	ldr	r3, [r7, #4]
 800e68a:	69db      	ldr	r3, [r3, #28]
 800e68c:	2b02      	cmp	r3, #2
 800e68e:	d146      	bne.n	800e71e <HAL_RCC_OscConfig+0x48a>
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800e690:	4b33      	ldr	r3, [pc, #204]	@ (800e760 <HAL_RCC_OscConfig+0x4cc>)
 800e692:	2200      	movs	r2, #0
 800e694:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800e696:	f7fe fdd7 	bl	800d248 <HAL_GetTick>
 800e69a:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800e69c:	e008      	b.n	800e6b0 <HAL_RCC_OscConfig+0x41c>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800e69e:	f7fe fdd3 	bl	800d248 <HAL_GetTick>
 800e6a2:	4602      	mov	r2, r0
 800e6a4:	693b      	ldr	r3, [r7, #16]
 800e6a6:	1ad3      	subs	r3, r2, r3
 800e6a8:	2b02      	cmp	r3, #2
 800e6aa:	d901      	bls.n	800e6b0 <HAL_RCC_OscConfig+0x41c>
          {
            return HAL_TIMEOUT;
 800e6ac:	2303      	movs	r3, #3
 800e6ae:	e06d      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800e6b0:	4b29      	ldr	r3, [pc, #164]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e6b2:	681b      	ldr	r3, [r3, #0]
 800e6b4:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800e6b8:	2b00      	cmp	r3, #0
 800e6ba:	d1f0      	bne.n	800e69e <HAL_RCC_OscConfig+0x40a>
          }
        }

        /* Configure the HSE prediv factor --------------------------------*/
        /* It can be written only when the PLL is disabled. Not used in PLL source is different than HSE */
        if (RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 800e6bc:	687b      	ldr	r3, [r7, #4]
 800e6be:	6a1b      	ldr	r3, [r3, #32]
 800e6c0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800e6c4:	d108      	bne.n	800e6d8 <HAL_RCC_OscConfig+0x444>
          /* Set PREDIV1 source */
          SET_BIT(RCC->CFGR2, RCC_OscInitStruct->Prediv1Source);
#endif /* RCC_CFGR2_PREDIV1SRC */

          /* Set PREDIV1 Value */
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 800e6c6:	4b24      	ldr	r3, [pc, #144]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e6c8:	685b      	ldr	r3, [r3, #4]
 800e6ca:	f423 3200 	bic.w	r2, r3, #131072	@ 0x20000
 800e6ce:	687b      	ldr	r3, [r7, #4]
 800e6d0:	689b      	ldr	r3, [r3, #8]
 800e6d2:	4921      	ldr	r1, [pc, #132]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e6d4:	4313      	orrs	r3, r2
 800e6d6:	604b      	str	r3, [r1, #4]
        }

        /* Configure the main PLL clock source and multiplication factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800e6d8:	4b1f      	ldr	r3, [pc, #124]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e6da:	685b      	ldr	r3, [r3, #4]
 800e6dc:	f423 1274 	bic.w	r2, r3, #3997696	@ 0x3d0000
 800e6e0:	687b      	ldr	r3, [r7, #4]
 800e6e2:	6a19      	ldr	r1, [r3, #32]
 800e6e4:	687b      	ldr	r3, [r7, #4]
 800e6e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800e6e8:	430b      	orrs	r3, r1
 800e6ea:	491b      	ldr	r1, [pc, #108]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e6ec:	4313      	orrs	r3, r2
 800e6ee:	604b      	str	r3, [r1, #4]
                             RCC_OscInitStruct->PLL.PLLMUL);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800e6f0:	4b1b      	ldr	r3, [pc, #108]	@ (800e760 <HAL_RCC_OscConfig+0x4cc>)
 800e6f2:	2201      	movs	r2, #1
 800e6f4:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800e6f6:	f7fe fda7 	bl	800d248 <HAL_GetTick>
 800e6fa:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800e6fc:	e008      	b.n	800e710 <HAL_RCC_OscConfig+0x47c>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800e6fe:	f7fe fda3 	bl	800d248 <HAL_GetTick>
 800e702:	4602      	mov	r2, r0
 800e704:	693b      	ldr	r3, [r7, #16]
 800e706:	1ad3      	subs	r3, r2, r3
 800e708:	2b02      	cmp	r3, #2
 800e70a:	d901      	bls.n	800e710 <HAL_RCC_OscConfig+0x47c>
          {
            return HAL_TIMEOUT;
 800e70c:	2303      	movs	r3, #3
 800e70e:	e03d      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800e710:	4b11      	ldr	r3, [pc, #68]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e712:	681b      	ldr	r3, [r3, #0]
 800e714:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800e718:	2b00      	cmp	r3, #0
 800e71a:	d0f0      	beq.n	800e6fe <HAL_RCC_OscConfig+0x46a>
 800e71c:	e035      	b.n	800e78a <HAL_RCC_OscConfig+0x4f6>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800e71e:	4b10      	ldr	r3, [pc, #64]	@ (800e760 <HAL_RCC_OscConfig+0x4cc>)
 800e720:	2200      	movs	r2, #0
 800e722:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800e724:	f7fe fd90 	bl	800d248 <HAL_GetTick>
 800e728:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800e72a:	e008      	b.n	800e73e <HAL_RCC_OscConfig+0x4aa>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800e72c:	f7fe fd8c 	bl	800d248 <HAL_GetTick>
 800e730:	4602      	mov	r2, r0
 800e732:	693b      	ldr	r3, [r7, #16]
 800e734:	1ad3      	subs	r3, r2, r3
 800e736:	2b02      	cmp	r3, #2
 800e738:	d901      	bls.n	800e73e <HAL_RCC_OscConfig+0x4aa>
          {
            return HAL_TIMEOUT;
 800e73a:	2303      	movs	r3, #3
 800e73c:	e026      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800e73e:	4b06      	ldr	r3, [pc, #24]	@ (800e758 <HAL_RCC_OscConfig+0x4c4>)
 800e740:	681b      	ldr	r3, [r3, #0]
 800e742:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800e746:	2b00      	cmp	r3, #0
 800e748:	d1f0      	bne.n	800e72c <HAL_RCC_OscConfig+0x498>
 800e74a:	e01e      	b.n	800e78a <HAL_RCC_OscConfig+0x4f6>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800e74c:	687b      	ldr	r3, [r7, #4]
 800e74e:	69db      	ldr	r3, [r3, #28]
 800e750:	2b01      	cmp	r3, #1
 800e752:	d107      	bne.n	800e764 <HAL_RCC_OscConfig+0x4d0>
      {
        return HAL_ERROR;
 800e754:	2301      	movs	r3, #1
 800e756:	e019      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
 800e758:	40021000 	.word	0x40021000
 800e75c:	40007000 	.word	0x40007000
 800e760:	42420060 	.word	0x42420060
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 800e764:	4b0b      	ldr	r3, [pc, #44]	@ (800e794 <HAL_RCC_OscConfig+0x500>)
 800e766:	685b      	ldr	r3, [r3, #4]
 800e768:	60fb      	str	r3, [r7, #12]
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800e76a:	68fb      	ldr	r3, [r7, #12]
 800e76c:	f403 3280 	and.w	r2, r3, #65536	@ 0x10000
 800e770:	687b      	ldr	r3, [r7, #4]
 800e772:	6a1b      	ldr	r3, [r3, #32]
 800e774:	429a      	cmp	r2, r3
 800e776:	d106      	bne.n	800e786 <HAL_RCC_OscConfig+0x4f2>
            (READ_BIT(pll_config, RCC_CFGR_PLLMULL) != RCC_OscInitStruct->PLL.PLLMUL))
 800e778:	68fb      	ldr	r3, [r7, #12]
 800e77a:	f403 1270 	and.w	r2, r3, #3932160	@ 0x3c0000
 800e77e:	687b      	ldr	r3, [r7, #4]
 800e780:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800e782:	429a      	cmp	r2, r3
 800e784:	d001      	beq.n	800e78a <HAL_RCC_OscConfig+0x4f6>
        {
          return HAL_ERROR;
 800e786:	2301      	movs	r3, #1
 800e788:	e000      	b.n	800e78c <HAL_RCC_OscConfig+0x4f8>
        }
      }
    }
  }

  return HAL_OK;
 800e78a:	2300      	movs	r3, #0
}
 800e78c:	4618      	mov	r0, r3
 800e78e:	3718      	adds	r7, #24
 800e790:	46bd      	mov	sp, r7
 800e792:	bd80      	pop	{r7, pc}
 800e794:	40021000 	.word	0x40021000

0800e798 <HAL_RCC_ClockConfig>:
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800e798:	b580      	push	{r7, lr}
 800e79a:	b084      	sub	sp, #16
 800e79c:	af00      	add	r7, sp, #0
 800e79e:	6078      	str	r0, [r7, #4]
 800e7a0:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 800e7a2:	687b      	ldr	r3, [r7, #4]
 800e7a4:	2b00      	cmp	r3, #0
 800e7a6:	d101      	bne.n	800e7ac <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800e7a8:	2301      	movs	r3, #1
 800e7aa:	e0d0      	b.n	800e94e <HAL_RCC_ClockConfig+0x1b6>
  must be correctly programmed according to the frequency of the CPU clock
    (HCLK) of the device. */

#if defined(FLASH_ACR_LATENCY)
  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800e7ac:	4b6a      	ldr	r3, [pc, #424]	@ (800e958 <HAL_RCC_ClockConfig+0x1c0>)
 800e7ae:	681b      	ldr	r3, [r3, #0]
 800e7b0:	f003 0307 	and.w	r3, r3, #7
 800e7b4:	683a      	ldr	r2, [r7, #0]
 800e7b6:	429a      	cmp	r2, r3
 800e7b8:	d910      	bls.n	800e7dc <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800e7ba:	4b67      	ldr	r3, [pc, #412]	@ (800e958 <HAL_RCC_ClockConfig+0x1c0>)
 800e7bc:	681b      	ldr	r3, [r3, #0]
 800e7be:	f023 0207 	bic.w	r2, r3, #7
 800e7c2:	4965      	ldr	r1, [pc, #404]	@ (800e958 <HAL_RCC_ClockConfig+0x1c0>)
 800e7c4:	683b      	ldr	r3, [r7, #0]
 800e7c6:	4313      	orrs	r3, r2
 800e7c8:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800e7ca:	4b63      	ldr	r3, [pc, #396]	@ (800e958 <HAL_RCC_ClockConfig+0x1c0>)
 800e7cc:	681b      	ldr	r3, [r3, #0]
 800e7ce:	f003 0307 	and.w	r3, r3, #7
 800e7d2:	683a      	ldr	r2, [r7, #0]
 800e7d4:	429a      	cmp	r2, r3
 800e7d6:	d001      	beq.n	800e7dc <HAL_RCC_ClockConfig+0x44>
  {
    return HAL_ERROR;
 800e7d8:	2301      	movs	r3, #1
 800e7da:	e0b8      	b.n	800e94e <HAL_RCC_ClockConfig+0x1b6>
  }
}

#endif /* FLASH_ACR_LATENCY */
/*-------------------------- HCLK Configuration --------------------------*/
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800e7dc:	687b      	ldr	r3, [r7, #4]
 800e7de:	681b      	ldr	r3, [r3, #0]
 800e7e0:	f003 0302 	and.w	r3, r3, #2
 800e7e4:	2b00      	cmp	r3, #0
 800e7e6:	d020      	beq.n	800e82a <HAL_RCC_ClockConfig+0x92>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
    a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800e7e8:	687b      	ldr	r3, [r7, #4]
 800e7ea:	681b      	ldr	r3, [r3, #0]
 800e7ec:	f003 0304 	and.w	r3, r3, #4
 800e7f0:	2b00      	cmp	r3, #0
 800e7f2:	d005      	beq.n	800e800 <HAL_RCC_ClockConfig+0x68>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800e7f4:	4b59      	ldr	r3, [pc, #356]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e7f6:	685b      	ldr	r3, [r3, #4]
 800e7f8:	4a58      	ldr	r2, [pc, #352]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e7fa:	f443 63e0 	orr.w	r3, r3, #1792	@ 0x700
 800e7fe:	6053      	str	r3, [r2, #4]
    }

    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800e800:	687b      	ldr	r3, [r7, #4]
 800e802:	681b      	ldr	r3, [r3, #0]
 800e804:	f003 0308 	and.w	r3, r3, #8
 800e808:	2b00      	cmp	r3, #0
 800e80a:	d005      	beq.n	800e818 <HAL_RCC_ClockConfig+0x80>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800e80c:	4b53      	ldr	r3, [pc, #332]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e80e:	685b      	ldr	r3, [r3, #4]
 800e810:	4a52      	ldr	r2, [pc, #328]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e812:	f443 5360 	orr.w	r3, r3, #14336	@ 0x3800
 800e816:	6053      	str	r3, [r2, #4]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800e818:	4b50      	ldr	r3, [pc, #320]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e81a:	685b      	ldr	r3, [r3, #4]
 800e81c:	f023 02f0 	bic.w	r2, r3, #240	@ 0xf0
 800e820:	687b      	ldr	r3, [r7, #4]
 800e822:	689b      	ldr	r3, [r3, #8]
 800e824:	494d      	ldr	r1, [pc, #308]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e826:	4313      	orrs	r3, r2
 800e828:	604b      	str	r3, [r1, #4]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800e82a:	687b      	ldr	r3, [r7, #4]
 800e82c:	681b      	ldr	r3, [r3, #0]
 800e82e:	f003 0301 	and.w	r3, r3, #1
 800e832:	2b00      	cmp	r3, #0
 800e834:	d040      	beq.n	800e8b8 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800e836:	687b      	ldr	r3, [r7, #4]
 800e838:	685b      	ldr	r3, [r3, #4]
 800e83a:	2b01      	cmp	r3, #1
 800e83c:	d107      	bne.n	800e84e <HAL_RCC_ClockConfig+0xb6>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800e83e:	4b47      	ldr	r3, [pc, #284]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e840:	681b      	ldr	r3, [r3, #0]
 800e842:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800e846:	2b00      	cmp	r3, #0
 800e848:	d115      	bne.n	800e876 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800e84a:	2301      	movs	r3, #1
 800e84c:	e07f      	b.n	800e94e <HAL_RCC_ClockConfig+0x1b6>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800e84e:	687b      	ldr	r3, [r7, #4]
 800e850:	685b      	ldr	r3, [r3, #4]
 800e852:	2b02      	cmp	r3, #2
 800e854:	d107      	bne.n	800e866 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800e856:	4b41      	ldr	r3, [pc, #260]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e858:	681b      	ldr	r3, [r3, #0]
 800e85a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800e85e:	2b00      	cmp	r3, #0
 800e860:	d109      	bne.n	800e876 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800e862:	2301      	movs	r3, #1
 800e864:	e073      	b.n	800e94e <HAL_RCC_ClockConfig+0x1b6>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800e866:	4b3d      	ldr	r3, [pc, #244]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e868:	681b      	ldr	r3, [r3, #0]
 800e86a:	f003 0302 	and.w	r3, r3, #2
 800e86e:	2b00      	cmp	r3, #0
 800e870:	d101      	bne.n	800e876 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800e872:	2301      	movs	r3, #1
 800e874:	e06b      	b.n	800e94e <HAL_RCC_ClockConfig+0x1b6>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800e876:	4b39      	ldr	r3, [pc, #228]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e878:	685b      	ldr	r3, [r3, #4]
 800e87a:	f023 0203 	bic.w	r2, r3, #3
 800e87e:	687b      	ldr	r3, [r7, #4]
 800e880:	685b      	ldr	r3, [r3, #4]
 800e882:	4936      	ldr	r1, [pc, #216]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e884:	4313      	orrs	r3, r2
 800e886:	604b      	str	r3, [r1, #4]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 800e888:	f7fe fcde 	bl	800d248 <HAL_GetTick>
 800e88c:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800e88e:	e00a      	b.n	800e8a6 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e890:	f7fe fcda 	bl	800d248 <HAL_GetTick>
 800e894:	4602      	mov	r2, r0
 800e896:	68fb      	ldr	r3, [r7, #12]
 800e898:	1ad3      	subs	r3, r2, r3
 800e89a:	f241 3288 	movw	r2, #5000	@ 0x1388
 800e89e:	4293      	cmp	r3, r2
 800e8a0:	d901      	bls.n	800e8a6 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 800e8a2:	2303      	movs	r3, #3
 800e8a4:	e053      	b.n	800e94e <HAL_RCC_ClockConfig+0x1b6>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800e8a6:	4b2d      	ldr	r3, [pc, #180]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e8a8:	685b      	ldr	r3, [r3, #4]
 800e8aa:	f003 020c 	and.w	r2, r3, #12
 800e8ae:	687b      	ldr	r3, [r7, #4]
 800e8b0:	685b      	ldr	r3, [r3, #4]
 800e8b2:	009b      	lsls	r3, r3, #2
 800e8b4:	429a      	cmp	r2, r3
 800e8b6:	d1eb      	bne.n	800e890 <HAL_RCC_ClockConfig+0xf8>
    }
  }

#if defined(FLASH_ACR_LATENCY)
  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800e8b8:	4b27      	ldr	r3, [pc, #156]	@ (800e958 <HAL_RCC_ClockConfig+0x1c0>)
 800e8ba:	681b      	ldr	r3, [r3, #0]
 800e8bc:	f003 0307 	and.w	r3, r3, #7
 800e8c0:	683a      	ldr	r2, [r7, #0]
 800e8c2:	429a      	cmp	r2, r3
 800e8c4:	d210      	bcs.n	800e8e8 <HAL_RCC_ClockConfig+0x150>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800e8c6:	4b24      	ldr	r3, [pc, #144]	@ (800e958 <HAL_RCC_ClockConfig+0x1c0>)
 800e8c8:	681b      	ldr	r3, [r3, #0]
 800e8ca:	f023 0207 	bic.w	r2, r3, #7
 800e8ce:	4922      	ldr	r1, [pc, #136]	@ (800e958 <HAL_RCC_ClockConfig+0x1c0>)
 800e8d0:	683b      	ldr	r3, [r7, #0]
 800e8d2:	4313      	orrs	r3, r2
 800e8d4:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800e8d6:	4b20      	ldr	r3, [pc, #128]	@ (800e958 <HAL_RCC_ClockConfig+0x1c0>)
 800e8d8:	681b      	ldr	r3, [r3, #0]
 800e8da:	f003 0307 	and.w	r3, r3, #7
 800e8de:	683a      	ldr	r2, [r7, #0]
 800e8e0:	429a      	cmp	r2, r3
 800e8e2:	d001      	beq.n	800e8e8 <HAL_RCC_ClockConfig+0x150>
  {
    return HAL_ERROR;
 800e8e4:	2301      	movs	r3, #1
 800e8e6:	e032      	b.n	800e94e <HAL_RCC_ClockConfig+0x1b6>
  }
}
#endif /* FLASH_ACR_LATENCY */

/*-------------------------- PCLK1 Configuration ---------------------------*/
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800e8e8:	687b      	ldr	r3, [r7, #4]
 800e8ea:	681b      	ldr	r3, [r3, #0]
 800e8ec:	f003 0304 	and.w	r3, r3, #4
 800e8f0:	2b00      	cmp	r3, #0
 800e8f2:	d008      	beq.n	800e906 <HAL_RCC_ClockConfig+0x16e>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800e8f4:	4b19      	ldr	r3, [pc, #100]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e8f6:	685b      	ldr	r3, [r3, #4]
 800e8f8:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 800e8fc:	687b      	ldr	r3, [r7, #4]
 800e8fe:	68db      	ldr	r3, [r3, #12]
 800e900:	4916      	ldr	r1, [pc, #88]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e902:	4313      	orrs	r3, r2
 800e904:	604b      	str	r3, [r1, #4]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800e906:	687b      	ldr	r3, [r7, #4]
 800e908:	681b      	ldr	r3, [r3, #0]
 800e90a:	f003 0308 	and.w	r3, r3, #8
 800e90e:	2b00      	cmp	r3, #0
 800e910:	d009      	beq.n	800e926 <HAL_RCC_ClockConfig+0x18e>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800e912:	4b12      	ldr	r3, [pc, #72]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e914:	685b      	ldr	r3, [r3, #4]
 800e916:	f423 5260 	bic.w	r2, r3, #14336	@ 0x3800
 800e91a:	687b      	ldr	r3, [r7, #4]
 800e91c:	691b      	ldr	r3, [r3, #16]
 800e91e:	00db      	lsls	r3, r3, #3
 800e920:	490e      	ldr	r1, [pc, #56]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e922:	4313      	orrs	r3, r2
 800e924:	604b      	str	r3, [r1, #4]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800e926:	f000 f821 	bl	800e96c <HAL_RCC_GetSysClockFreq>
 800e92a:	4602      	mov	r2, r0
 800e92c:	4b0b      	ldr	r3, [pc, #44]	@ (800e95c <HAL_RCC_ClockConfig+0x1c4>)
 800e92e:	685b      	ldr	r3, [r3, #4]
 800e930:	091b      	lsrs	r3, r3, #4
 800e932:	f003 030f 	and.w	r3, r3, #15
 800e936:	490a      	ldr	r1, [pc, #40]	@ (800e960 <HAL_RCC_ClockConfig+0x1c8>)
 800e938:	5ccb      	ldrb	r3, [r1, r3]
 800e93a:	fa22 f303 	lsr.w	r3, r2, r3
 800e93e:	4a09      	ldr	r2, [pc, #36]	@ (800e964 <HAL_RCC_ClockConfig+0x1cc>)
 800e940:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);
 800e942:	4b09      	ldr	r3, [pc, #36]	@ (800e968 <HAL_RCC_ClockConfig+0x1d0>)
 800e944:	681b      	ldr	r3, [r3, #0]
 800e946:	4618      	mov	r0, r3
 800e948:	f7fe fc3c 	bl	800d1c4 <HAL_InitTick>

  return HAL_OK;
 800e94c:	2300      	movs	r3, #0
}
 800e94e:	4618      	mov	r0, r3
 800e950:	3710      	adds	r7, #16
 800e952:	46bd      	mov	sp, r7
 800e954:	bd80      	pop	{r7, pc}
 800e956:	bf00      	nop
 800e958:	40022000 	.word	0x40022000
 800e95c:	40021000 	.word	0x40021000
 800e960:	0800eee0 	.word	0x0800eee0
 800e964:	20000004 	.word	0x20000004
 800e968:	20000008 	.word	0x20000008

0800e96c <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800e96c:	b480      	push	{r7}
 800e96e:	b087      	sub	sp, #28
 800e970:	af00      	add	r7, sp, #0
#else
  static const uint8_t aPredivFactorTable[2U] = {1, 2};
#endif /*RCC_CFGR2_PREDIV1*/

#endif
  uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U;
 800e972:	2300      	movs	r3, #0
 800e974:	60fb      	str	r3, [r7, #12]
 800e976:	2300      	movs	r3, #0
 800e978:	60bb      	str	r3, [r7, #8]
 800e97a:	2300      	movs	r3, #0
 800e97c:	617b      	str	r3, [r7, #20]
 800e97e:	2300      	movs	r3, #0
 800e980:	607b      	str	r3, [r7, #4]
  uint32_t sysclockfreq = 0U;
 800e982:	2300      	movs	r3, #0
 800e984:	613b      	str	r3, [r7, #16]
#if defined(RCC_CFGR2_PREDIV1SRC)
  uint32_t prediv2 = 0U, pll2mul = 0U;
#endif /*RCC_CFGR2_PREDIV1SRC*/

  tmpreg = RCC->CFGR;
 800e986:	4b1e      	ldr	r3, [pc, #120]	@ (800ea00 <HAL_RCC_GetSysClockFreq+0x94>)
 800e988:	685b      	ldr	r3, [r3, #4]
 800e98a:	60fb      	str	r3, [r7, #12]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 800e98c:	68fb      	ldr	r3, [r7, #12]
 800e98e:	f003 030c 	and.w	r3, r3, #12
 800e992:	2b04      	cmp	r3, #4
 800e994:	d002      	beq.n	800e99c <HAL_RCC_GetSysClockFreq+0x30>
 800e996:	2b08      	cmp	r3, #8
 800e998:	d003      	beq.n	800e9a2 <HAL_RCC_GetSysClockFreq+0x36>
 800e99a:	e027      	b.n	800e9ec <HAL_RCC_GetSysClockFreq+0x80>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 800e99c:	4b19      	ldr	r3, [pc, #100]	@ (800ea04 <HAL_RCC_GetSysClockFreq+0x98>)
 800e99e:	613b      	str	r3, [r7, #16]
      break;
 800e9a0:	e027      	b.n	800e9f2 <HAL_RCC_GetSysClockFreq+0x86>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 800e9a2:	68fb      	ldr	r3, [r7, #12]
 800e9a4:	0c9b      	lsrs	r3, r3, #18
 800e9a6:	f003 030f 	and.w	r3, r3, #15
 800e9aa:	4a17      	ldr	r2, [pc, #92]	@ (800ea08 <HAL_RCC_GetSysClockFreq+0x9c>)
 800e9ac:	5cd3      	ldrb	r3, [r2, r3]
 800e9ae:	607b      	str	r3, [r7, #4]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 800e9b0:	68fb      	ldr	r3, [r7, #12]
 800e9b2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800e9b6:	2b00      	cmp	r3, #0
 800e9b8:	d010      	beq.n	800e9dc <HAL_RCC_GetSysClockFreq+0x70>
      {
#if defined(RCC_CFGR2_PREDIV1)
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> RCC_CFGR2_PREDIV1_Pos];
#else
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 800e9ba:	4b11      	ldr	r3, [pc, #68]	@ (800ea00 <HAL_RCC_GetSysClockFreq+0x94>)
 800e9bc:	685b      	ldr	r3, [r3, #4]
 800e9be:	0c5b      	lsrs	r3, r3, #17
 800e9c0:	f003 0301 	and.w	r3, r3, #1
 800e9c4:	4a11      	ldr	r2, [pc, #68]	@ (800ea0c <HAL_RCC_GetSysClockFreq+0xa0>)
 800e9c6:	5cd3      	ldrb	r3, [r2, r3]
 800e9c8:	60bb      	str	r3, [r7, #8]
        {
          pllclk = pllclk / 2;
        }
#else
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 800e9ca:	687b      	ldr	r3, [r7, #4]
 800e9cc:	4a0d      	ldr	r2, [pc, #52]	@ (800ea04 <HAL_RCC_GetSysClockFreq+0x98>)
 800e9ce:	fb03 f202 	mul.w	r2, r3, r2
 800e9d2:	68bb      	ldr	r3, [r7, #8]
 800e9d4:	fbb2 f3f3 	udiv	r3, r2, r3
 800e9d8:	617b      	str	r3, [r7, #20]
 800e9da:	e004      	b.n	800e9e6 <HAL_RCC_GetSysClockFreq+0x7a>
#endif /*RCC_CFGR2_PREDIV1SRC*/
      }
      else
      {
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 800e9dc:	687b      	ldr	r3, [r7, #4]
 800e9de:	4a0c      	ldr	r2, [pc, #48]	@ (800ea10 <HAL_RCC_GetSysClockFreq+0xa4>)
 800e9e0:	fb02 f303 	mul.w	r3, r2, r3
 800e9e4:	617b      	str	r3, [r7, #20]
      }
      sysclockfreq = pllclk;
 800e9e6:	697b      	ldr	r3, [r7, #20]
 800e9e8:	613b      	str	r3, [r7, #16]
      break;
 800e9ea:	e002      	b.n	800e9f2 <HAL_RCC_GetSysClockFreq+0x86>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    default: /* HSI used as system clock */
    {
      sysclockfreq = HSI_VALUE;
 800e9ec:	4b05      	ldr	r3, [pc, #20]	@ (800ea04 <HAL_RCC_GetSysClockFreq+0x98>)
 800e9ee:	613b      	str	r3, [r7, #16]
      break;
 800e9f0:	bf00      	nop
    }
  }
  return sysclockfreq;
 800e9f2:	693b      	ldr	r3, [r7, #16]
}
 800e9f4:	4618      	mov	r0, r3
 800e9f6:	371c      	adds	r7, #28
 800e9f8:	46bd      	mov	sp, r7
 800e9fa:	bc80      	pop	{r7}
 800e9fc:	4770      	bx	lr
 800e9fe:	bf00      	nop
 800ea00:	40021000 	.word	0x40021000
 800ea04:	007a1200 	.word	0x007a1200
 800ea08:	0800eef8 	.word	0x0800eef8
 800ea0c:	0800ef08 	.word	0x0800ef08
 800ea10:	003d0900 	.word	0x003d0900

0800ea14 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800ea14:	b480      	push	{r7}
 800ea16:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800ea18:	4b02      	ldr	r3, [pc, #8]	@ (800ea24 <HAL_RCC_GetHCLKFreq+0x10>)
 800ea1a:	681b      	ldr	r3, [r3, #0]
}
 800ea1c:	4618      	mov	r0, r3
 800ea1e:	46bd      	mov	sp, r7
 800ea20:	bc80      	pop	{r7}
 800ea22:	4770      	bx	lr
 800ea24:	20000004 	.word	0x20000004

0800ea28 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800ea28:	b580      	push	{r7, lr}
 800ea2a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800ea2c:	f7ff fff2 	bl	800ea14 <HAL_RCC_GetHCLKFreq>
 800ea30:	4602      	mov	r2, r0
 800ea32:	4b05      	ldr	r3, [pc, #20]	@ (800ea48 <HAL_RCC_GetPCLK1Freq+0x20>)
 800ea34:	685b      	ldr	r3, [r3, #4]
 800ea36:	0a1b      	lsrs	r3, r3, #8
 800ea38:	f003 0307 	and.w	r3, r3, #7
 800ea3c:	4903      	ldr	r1, [pc, #12]	@ (800ea4c <HAL_RCC_GetPCLK1Freq+0x24>)
 800ea3e:	5ccb      	ldrb	r3, [r1, r3]
 800ea40:	fa22 f303 	lsr.w	r3, r2, r3
}
 800ea44:	4618      	mov	r0, r3
 800ea46:	bd80      	pop	{r7, pc}
 800ea48:	40021000 	.word	0x40021000
 800ea4c:	0800eef0 	.word	0x0800eef0

0800ea50 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800ea50:	b580      	push	{r7, lr}
 800ea52:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800ea54:	f7ff ffde 	bl	800ea14 <HAL_RCC_GetHCLKFreq>
 800ea58:	4602      	mov	r2, r0
 800ea5a:	4b05      	ldr	r3, [pc, #20]	@ (800ea70 <HAL_RCC_GetPCLK2Freq+0x20>)
 800ea5c:	685b      	ldr	r3, [r3, #4]
 800ea5e:	0adb      	lsrs	r3, r3, #11
 800ea60:	f003 0307 	and.w	r3, r3, #7
 800ea64:	4903      	ldr	r1, [pc, #12]	@ (800ea74 <HAL_RCC_GetPCLK2Freq+0x24>)
 800ea66:	5ccb      	ldrb	r3, [r1, r3]
 800ea68:	fa22 f303 	lsr.w	r3, r2, r3
}
 800ea6c:	4618      	mov	r0, r3
 800ea6e:	bd80      	pop	{r7, pc}
 800ea70:	40021000 	.word	0x40021000
 800ea74:	0800eef0 	.word	0x0800eef0

0800ea78 <RCC_Delay>:
  * @brief  This function provides delay (in milliseconds) based on CPU cycles method.
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
 800ea78:	b480      	push	{r7}
 800ea7a:	b085      	sub	sp, #20
 800ea7c:	af00      	add	r7, sp, #0
 800ea7e:	6078      	str	r0, [r7, #4]
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 800ea80:	4b0a      	ldr	r3, [pc, #40]	@ (800eaac <RCC_Delay+0x34>)
 800ea82:	681b      	ldr	r3, [r3, #0]
 800ea84:	4a0a      	ldr	r2, [pc, #40]	@ (800eab0 <RCC_Delay+0x38>)
 800ea86:	fba2 2303 	umull	r2, r3, r2, r3
 800ea8a:	0a5b      	lsrs	r3, r3, #9
 800ea8c:	687a      	ldr	r2, [r7, #4]
 800ea8e:	fb02 f303 	mul.w	r3, r2, r3
 800ea92:	60fb      	str	r3, [r7, #12]
  do
  {
    __NOP();
 800ea94:	bf00      	nop
  }
  while (Delay --);
 800ea96:	68fb      	ldr	r3, [r7, #12]
 800ea98:	1e5a      	subs	r2, r3, #1
 800ea9a:	60fa      	str	r2, [r7, #12]
 800ea9c:	2b00      	cmp	r3, #0
 800ea9e:	d1f9      	bne.n	800ea94 <RCC_Delay+0x1c>
}
 800eaa0:	bf00      	nop
 800eaa2:	bf00      	nop
 800eaa4:	3714      	adds	r7, #20
 800eaa6:	46bd      	mov	sp, r7
 800eaa8:	bc80      	pop	{r7}
 800eaaa:	4770      	bx	lr
 800eaac:	20000004 	.word	0x20000004
 800eab0:	10624dd3 	.word	0x10624dd3

0800eab4 <HAL_UART_Init>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800eab4:	b580      	push	{r7, lr}
 800eab6:	b082      	sub	sp, #8
 800eab8:	af00      	add	r7, sp, #0
 800eaba:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 800eabc:	687b      	ldr	r3, [r7, #4]
 800eabe:	2b00      	cmp	r3, #0
 800eac0:	d101      	bne.n	800eac6 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800eac2:	2301      	movs	r3, #1
 800eac4:	e042      	b.n	800eb4c <HAL_UART_Init+0x98>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
#if defined(USART_CR1_OVER8)
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
#endif /* USART_CR1_OVER8 */

  if (huart->gState == HAL_UART_STATE_RESET)
 800eac6:	687b      	ldr	r3, [r7, #4]
 800eac8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800eacc:	b2db      	uxtb	r3, r3
 800eace:	2b00      	cmp	r3, #0
 800ead0:	d106      	bne.n	800eae0 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800ead2:	687b      	ldr	r3, [r7, #4]
 800ead4:	2200      	movs	r2, #0
 800ead6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800eada:	6878      	ldr	r0, [r7, #4]
 800eadc:	f7fe faae 	bl	800d03c <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800eae0:	687b      	ldr	r3, [r7, #4]
 800eae2:	2224      	movs	r2, #36	@ 0x24
 800eae4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 800eae8:	687b      	ldr	r3, [r7, #4]
 800eaea:	681b      	ldr	r3, [r3, #0]
 800eaec:	68da      	ldr	r2, [r3, #12]
 800eaee:	687b      	ldr	r3, [r7, #4]
 800eaf0:	681b      	ldr	r3, [r3, #0]
 800eaf2:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 800eaf6:	60da      	str	r2, [r3, #12]

  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 800eaf8:	6878      	ldr	r0, [r7, #4]
 800eafa:	f000 f92b 	bl	800ed54 <UART_SetConfig>

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800eafe:	687b      	ldr	r3, [r7, #4]
 800eb00:	681b      	ldr	r3, [r3, #0]
 800eb02:	691a      	ldr	r2, [r3, #16]
 800eb04:	687b      	ldr	r3, [r7, #4]
 800eb06:	681b      	ldr	r3, [r3, #0]
 800eb08:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 800eb0c:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800eb0e:	687b      	ldr	r3, [r7, #4]
 800eb10:	681b      	ldr	r3, [r3, #0]
 800eb12:	695a      	ldr	r2, [r3, #20]
 800eb14:	687b      	ldr	r3, [r7, #4]
 800eb16:	681b      	ldr	r3, [r3, #0]
 800eb18:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 800eb1c:	615a      	str	r2, [r3, #20]

  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 800eb1e:	687b      	ldr	r3, [r7, #4]
 800eb20:	681b      	ldr	r3, [r3, #0]
 800eb22:	68da      	ldr	r2, [r3, #12]
 800eb24:	687b      	ldr	r3, [r7, #4]
 800eb26:	681b      	ldr	r3, [r3, #0]
 800eb28:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 800eb2c:	60da      	str	r2, [r3, #12]

  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800eb2e:	687b      	ldr	r3, [r7, #4]
 800eb30:	2200      	movs	r2, #0
 800eb32:	645a      	str	r2, [r3, #68]	@ 0x44
  huart->gState = HAL_UART_STATE_READY;
 800eb34:	687b      	ldr	r3, [r7, #4]
 800eb36:	2220      	movs	r2, #32
 800eb38:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  huart->RxState = HAL_UART_STATE_READY;
 800eb3c:	687b      	ldr	r3, [r7, #4]
 800eb3e:	2220      	movs	r2, #32
 800eb40:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 800eb44:	687b      	ldr	r3, [r7, #4]
 800eb46:	2200      	movs	r2, #0
 800eb48:	635a      	str	r2, [r3, #52]	@ 0x34

  return HAL_OK;
 800eb4a:	2300      	movs	r3, #0
}
 800eb4c:	4618      	mov	r0, r3
 800eb4e:	3708      	adds	r7, #8
 800eb50:	46bd      	mov	sp, r7
 800eb52:	bd80      	pop	{r7, pc}

0800eb54 <HAL_UART_Receive>:
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800eb54:	b580      	push	{r7, lr}
 800eb56:	b08a      	sub	sp, #40	@ 0x28
 800eb58:	af02      	add	r7, sp, #8
 800eb5a:	60f8      	str	r0, [r7, #12]
 800eb5c:	60b9      	str	r1, [r7, #8]
 800eb5e:	603b      	str	r3, [r7, #0]
 800eb60:	4613      	mov	r3, r2
 800eb62:	80fb      	strh	r3, [r7, #6]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart = 0U;
 800eb64:	2300      	movs	r3, #0
 800eb66:	617b      	str	r3, [r7, #20]

  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 800eb68:	68fb      	ldr	r3, [r7, #12]
 800eb6a:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 800eb6e:	b2db      	uxtb	r3, r3
 800eb70:	2b20      	cmp	r3, #32
 800eb72:	d17c      	bne.n	800ec6e <HAL_UART_Receive+0x11a>
  {
    if ((pData == NULL) || (Size == 0U))
 800eb74:	68bb      	ldr	r3, [r7, #8]
 800eb76:	2b00      	cmp	r3, #0
 800eb78:	d002      	beq.n	800eb80 <HAL_UART_Receive+0x2c>
 800eb7a:	88fb      	ldrh	r3, [r7, #6]
 800eb7c:	2b00      	cmp	r3, #0
 800eb7e:	d101      	bne.n	800eb84 <HAL_UART_Receive+0x30>
    {
      return  HAL_ERROR;
 800eb80:	2301      	movs	r3, #1
 800eb82:	e075      	b.n	800ec70 <HAL_UART_Receive+0x11c>
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800eb84:	68fb      	ldr	r3, [r7, #12]
 800eb86:	2200      	movs	r2, #0
 800eb88:	645a      	str	r2, [r3, #68]	@ 0x44
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800eb8a:	68fb      	ldr	r3, [r7, #12]
 800eb8c:	2222      	movs	r2, #34	@ 0x22
 800eb8e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800eb92:	68fb      	ldr	r3, [r7, #12]
 800eb94:	2200      	movs	r2, #0
 800eb96:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800eb98:	f7fe fb56 	bl	800d248 <HAL_GetTick>
 800eb9c:	6178      	str	r0, [r7, #20]

    huart->RxXferSize = Size;
 800eb9e:	68fb      	ldr	r3, [r7, #12]
 800eba0:	88fa      	ldrh	r2, [r7, #6]
 800eba2:	859a      	strh	r2, [r3, #44]	@ 0x2c
    huart->RxXferCount = Size;
 800eba4:	68fb      	ldr	r3, [r7, #12]
 800eba6:	88fa      	ldrh	r2, [r7, #6]
 800eba8:	85da      	strh	r2, [r3, #46]	@ 0x2e

    /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800ebaa:	68fb      	ldr	r3, [r7, #12]
 800ebac:	689b      	ldr	r3, [r3, #8]
 800ebae:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800ebb2:	d108      	bne.n	800ebc6 <HAL_UART_Receive+0x72>
 800ebb4:	68fb      	ldr	r3, [r7, #12]
 800ebb6:	691b      	ldr	r3, [r3, #16]
 800ebb8:	2b00      	cmp	r3, #0
 800ebba:	d104      	bne.n	800ebc6 <HAL_UART_Receive+0x72>
    {
      pdata8bits  = NULL;
 800ebbc:	2300      	movs	r3, #0
 800ebbe:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 800ebc0:	68bb      	ldr	r3, [r7, #8]
 800ebc2:	61bb      	str	r3, [r7, #24]
 800ebc4:	e003      	b.n	800ebce <HAL_UART_Receive+0x7a>
    }
    else
    {
      pdata8bits  = pData;
 800ebc6:	68bb      	ldr	r3, [r7, #8]
 800ebc8:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 800ebca:	2300      	movs	r3, #0
 800ebcc:	61bb      	str	r3, [r7, #24]
    }

    /* Check the remain data to be received */
    while (huart->RxXferCount > 0U)
 800ebce:	e043      	b.n	800ec58 <HAL_UART_Receive+0x104>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 800ebd0:	683b      	ldr	r3, [r7, #0]
 800ebd2:	9300      	str	r3, [sp, #0]
 800ebd4:	697b      	ldr	r3, [r7, #20]
 800ebd6:	2200      	movs	r2, #0
 800ebd8:	2120      	movs	r1, #32
 800ebda:	68f8      	ldr	r0, [r7, #12]
 800ebdc:	f000 f84c 	bl	800ec78 <UART_WaitOnFlagUntilTimeout>
 800ebe0:	4603      	mov	r3, r0
 800ebe2:	2b00      	cmp	r3, #0
 800ebe4:	d001      	beq.n	800ebea <HAL_UART_Receive+0x96>
      {
        return HAL_TIMEOUT;
 800ebe6:	2303      	movs	r3, #3
 800ebe8:	e042      	b.n	800ec70 <HAL_UART_Receive+0x11c>
      }
      if (pdata8bits == NULL)
 800ebea:	69fb      	ldr	r3, [r7, #28]
 800ebec:	2b00      	cmp	r3, #0
 800ebee:	d10c      	bne.n	800ec0a <HAL_UART_Receive+0xb6>
      {
        *pdata16bits = (uint16_t)(huart->Instance->DR & 0x01FF);
 800ebf0:	68fb      	ldr	r3, [r7, #12]
 800ebf2:	681b      	ldr	r3, [r3, #0]
 800ebf4:	685b      	ldr	r3, [r3, #4]
 800ebf6:	b29b      	uxth	r3, r3
 800ebf8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800ebfc:	b29a      	uxth	r2, r3
 800ebfe:	69bb      	ldr	r3, [r7, #24]
 800ec00:	801a      	strh	r2, [r3, #0]
        pdata16bits++;
 800ec02:	69bb      	ldr	r3, [r7, #24]
 800ec04:	3302      	adds	r3, #2
 800ec06:	61bb      	str	r3, [r7, #24]
 800ec08:	e01f      	b.n	800ec4a <HAL_UART_Receive+0xf6>
      }
      else
      {
        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 800ec0a:	68fb      	ldr	r3, [r7, #12]
 800ec0c:	689b      	ldr	r3, [r3, #8]
 800ec0e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800ec12:	d007      	beq.n	800ec24 <HAL_UART_Receive+0xd0>
 800ec14:	68fb      	ldr	r3, [r7, #12]
 800ec16:	689b      	ldr	r3, [r3, #8]
 800ec18:	2b00      	cmp	r3, #0
 800ec1a:	d10a      	bne.n	800ec32 <HAL_UART_Receive+0xde>
 800ec1c:	68fb      	ldr	r3, [r7, #12]
 800ec1e:	691b      	ldr	r3, [r3, #16]
 800ec20:	2b00      	cmp	r3, #0
 800ec22:	d106      	bne.n	800ec32 <HAL_UART_Receive+0xde>
        {
          *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 800ec24:	68fb      	ldr	r3, [r7, #12]
 800ec26:	681b      	ldr	r3, [r3, #0]
 800ec28:	685b      	ldr	r3, [r3, #4]
 800ec2a:	b2da      	uxtb	r2, r3
 800ec2c:	69fb      	ldr	r3, [r7, #28]
 800ec2e:	701a      	strb	r2, [r3, #0]
 800ec30:	e008      	b.n	800ec44 <HAL_UART_Receive+0xf0>
        }
        else
        {
          *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 800ec32:	68fb      	ldr	r3, [r7, #12]
 800ec34:	681b      	ldr	r3, [r3, #0]
 800ec36:	685b      	ldr	r3, [r3, #4]
 800ec38:	b2db      	uxtb	r3, r3
 800ec3a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800ec3e:	b2da      	uxtb	r2, r3
 800ec40:	69fb      	ldr	r3, [r7, #28]
 800ec42:	701a      	strb	r2, [r3, #0]
        }
        pdata8bits++;
 800ec44:	69fb      	ldr	r3, [r7, #28]
 800ec46:	3301      	adds	r3, #1
 800ec48:	61fb      	str	r3, [r7, #28]
      }
      huart->RxXferCount--;
 800ec4a:	68fb      	ldr	r3, [r7, #12]
 800ec4c:	8ddb      	ldrh	r3, [r3, #46]	@ 0x2e
 800ec4e:	b29b      	uxth	r3, r3
 800ec50:	3b01      	subs	r3, #1
 800ec52:	b29a      	uxth	r2, r3
 800ec54:	68fb      	ldr	r3, [r7, #12]
 800ec56:	85da      	strh	r2, [r3, #46]	@ 0x2e
    while (huart->RxXferCount > 0U)
 800ec58:	68fb      	ldr	r3, [r7, #12]
 800ec5a:	8ddb      	ldrh	r3, [r3, #46]	@ 0x2e
 800ec5c:	b29b      	uxth	r3, r3
 800ec5e:	2b00      	cmp	r3, #0
 800ec60:	d1b6      	bne.n	800ebd0 <HAL_UART_Receive+0x7c>
    }

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
 800ec62:	68fb      	ldr	r3, [r7, #12]
 800ec64:	2220      	movs	r2, #32
 800ec66:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    return HAL_OK;
 800ec6a:	2300      	movs	r3, #0
 800ec6c:	e000      	b.n	800ec70 <HAL_UART_Receive+0x11c>
  }
  else
  {
    return HAL_BUSY;
 800ec6e:	2302      	movs	r3, #2
  }
}
 800ec70:	4618      	mov	r0, r3
 800ec72:	3720      	adds	r7, #32
 800ec74:	46bd      	mov	sp, r7
 800ec76:	bd80      	pop	{r7, pc}

0800ec78 <UART_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                                     uint32_t Tickstart, uint32_t Timeout)
{
 800ec78:	b580      	push	{r7, lr}
 800ec7a:	b090      	sub	sp, #64	@ 0x40
 800ec7c:	af00      	add	r7, sp, #0
 800ec7e:	60f8      	str	r0, [r7, #12]
 800ec80:	60b9      	str	r1, [r7, #8]
 800ec82:	603b      	str	r3, [r7, #0]
 800ec84:	4613      	mov	r3, r2
 800ec86:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800ec88:	e050      	b.n	800ed2c <UART_WaitOnFlagUntilTimeout+0xb4>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800ec8a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800ec8c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ec90:	d04c      	beq.n	800ed2c <UART_WaitOnFlagUntilTimeout+0xb4>
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 800ec92:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800ec94:	2b00      	cmp	r3, #0
 800ec96:	d007      	beq.n	800eca8 <UART_WaitOnFlagUntilTimeout+0x30>
 800ec98:	f7fe fad6 	bl	800d248 <HAL_GetTick>
 800ec9c:	4602      	mov	r2, r0
 800ec9e:	683b      	ldr	r3, [r7, #0]
 800eca0:	1ad3      	subs	r3, r2, r3
 800eca2:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800eca4:	429a      	cmp	r2, r3
 800eca6:	d241      	bcs.n	800ed2c <UART_WaitOnFlagUntilTimeout+0xb4>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800eca8:	68fb      	ldr	r3, [r7, #12]
 800ecaa:	681b      	ldr	r3, [r3, #0]
 800ecac:	330c      	adds	r3, #12
 800ecae:	62bb      	str	r3, [r7, #40]	@ 0x28
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ecb0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ecb2:	e853 3f00 	ldrex	r3, [r3]
 800ecb6:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
 800ecb8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ecba:	f423 73d0 	bic.w	r3, r3, #416	@ 0x1a0
 800ecbe:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800ecc0:	68fb      	ldr	r3, [r7, #12]
 800ecc2:	681b      	ldr	r3, [r3, #0]
 800ecc4:	330c      	adds	r3, #12
 800ecc6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800ecc8:	637a      	str	r2, [r7, #52]	@ 0x34
 800ecca:	633b      	str	r3, [r7, #48]	@ 0x30
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800eccc:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 800ecce:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800ecd0:	e841 2300 	strex	r3, r2, [r1]
 800ecd4:	62fb      	str	r3, [r7, #44]	@ 0x2c
   return(result);
 800ecd6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ecd8:	2b00      	cmp	r3, #0
 800ecda:	d1e5      	bne.n	800eca8 <UART_WaitOnFlagUntilTimeout+0x30>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ecdc:	68fb      	ldr	r3, [r7, #12]
 800ecde:	681b      	ldr	r3, [r3, #0]
 800ece0:	3314      	adds	r3, #20
 800ece2:	617b      	str	r3, [r7, #20]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ece4:	697b      	ldr	r3, [r7, #20]
 800ece6:	e853 3f00 	ldrex	r3, [r3]
 800ecea:	613b      	str	r3, [r7, #16]
   return(result);
 800ecec:	693b      	ldr	r3, [r7, #16]
 800ecee:	f023 0301 	bic.w	r3, r3, #1
 800ecf2:	63bb      	str	r3, [r7, #56]	@ 0x38
 800ecf4:	68fb      	ldr	r3, [r7, #12]
 800ecf6:	681b      	ldr	r3, [r3, #0]
 800ecf8:	3314      	adds	r3, #20
 800ecfa:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800ecfc:	623a      	str	r2, [r7, #32]
 800ecfe:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ed00:	69f9      	ldr	r1, [r7, #28]
 800ed02:	6a3a      	ldr	r2, [r7, #32]
 800ed04:	e841 2300 	strex	r3, r2, [r1]
 800ed08:	61bb      	str	r3, [r7, #24]
   return(result);
 800ed0a:	69bb      	ldr	r3, [r7, #24]
 800ed0c:	2b00      	cmp	r3, #0
 800ed0e:	d1e5      	bne.n	800ecdc <UART_WaitOnFlagUntilTimeout+0x64>

        huart->gState  = HAL_UART_STATE_READY;
 800ed10:	68fb      	ldr	r3, [r7, #12]
 800ed12:	2220      	movs	r2, #32
 800ed14:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
        huart->RxState = HAL_UART_STATE_READY;
 800ed18:	68fb      	ldr	r3, [r7, #12]
 800ed1a:	2220      	movs	r2, #32
 800ed1c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 800ed20:	68fb      	ldr	r3, [r7, #12]
 800ed22:	2200      	movs	r2, #0
 800ed24:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

        return HAL_TIMEOUT;
 800ed28:	2303      	movs	r3, #3
 800ed2a:	e00f      	b.n	800ed4c <UART_WaitOnFlagUntilTimeout+0xd4>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800ed2c:	68fb      	ldr	r3, [r7, #12]
 800ed2e:	681b      	ldr	r3, [r3, #0]
 800ed30:	681a      	ldr	r2, [r3, #0]
 800ed32:	68bb      	ldr	r3, [r7, #8]
 800ed34:	4013      	ands	r3, r2
 800ed36:	68ba      	ldr	r2, [r7, #8]
 800ed38:	429a      	cmp	r2, r3
 800ed3a:	bf0c      	ite	eq
 800ed3c:	2301      	moveq	r3, #1
 800ed3e:	2300      	movne	r3, #0
 800ed40:	b2db      	uxtb	r3, r3
 800ed42:	461a      	mov	r2, r3
 800ed44:	79fb      	ldrb	r3, [r7, #7]
 800ed46:	429a      	cmp	r2, r3
 800ed48:	d09f      	beq.n	800ec8a <UART_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 800ed4a:	2300      	movs	r3, #0
}
 800ed4c:	4618      	mov	r0, r3
 800ed4e:	3740      	adds	r7, #64	@ 0x40
 800ed50:	46bd      	mov	sp, r7
 800ed52:	bd80      	pop	{r7, pc}

0800ed54 <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 800ed54:	b580      	push	{r7, lr}
 800ed56:	b084      	sub	sp, #16
 800ed58:	af00      	add	r7, sp, #0
 800ed5a:	6078      	str	r0, [r7, #4]
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800ed5c:	687b      	ldr	r3, [r7, #4]
 800ed5e:	681b      	ldr	r3, [r3, #0]
 800ed60:	691b      	ldr	r3, [r3, #16]
 800ed62:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
 800ed66:	687b      	ldr	r3, [r7, #4]
 800ed68:	68da      	ldr	r2, [r3, #12]
 800ed6a:	687b      	ldr	r3, [r7, #4]
 800ed6c:	681b      	ldr	r3, [r3, #0]
 800ed6e:	430a      	orrs	r2, r1
 800ed70:	611a      	str	r2, [r3, #16]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1,
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);
#else
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 800ed72:	687b      	ldr	r3, [r7, #4]
 800ed74:	689a      	ldr	r2, [r3, #8]
 800ed76:	687b      	ldr	r3, [r7, #4]
 800ed78:	691b      	ldr	r3, [r3, #16]
 800ed7a:	431a      	orrs	r2, r3
 800ed7c:	687b      	ldr	r3, [r7, #4]
 800ed7e:	695b      	ldr	r3, [r3, #20]
 800ed80:	4313      	orrs	r3, r2
 800ed82:	60bb      	str	r3, [r7, #8]
  MODIFY_REG(huart->Instance->CR1,
 800ed84:	687b      	ldr	r3, [r7, #4]
 800ed86:	681b      	ldr	r3, [r3, #0]
 800ed88:	68db      	ldr	r3, [r3, #12]
 800ed8a:	f423 53b0 	bic.w	r3, r3, #5632	@ 0x1600
 800ed8e:	f023 030c 	bic.w	r3, r3, #12
 800ed92:	687a      	ldr	r2, [r7, #4]
 800ed94:	6812      	ldr	r2, [r2, #0]
 800ed96:	68b9      	ldr	r1, [r7, #8]
 800ed98:	430b      	orrs	r3, r1
 800ed9a:	60d3      	str	r3, [r2, #12]
             tmpreg);
#endif /* USART_CR1_OVER8 */

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 800ed9c:	687b      	ldr	r3, [r7, #4]
 800ed9e:	681b      	ldr	r3, [r3, #0]
 800eda0:	695b      	ldr	r3, [r3, #20]
 800eda2:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 800eda6:	687b      	ldr	r3, [r7, #4]
 800eda8:	699a      	ldr	r2, [r3, #24]
 800edaa:	687b      	ldr	r3, [r7, #4]
 800edac:	681b      	ldr	r3, [r3, #0]
 800edae:	430a      	orrs	r2, r1
 800edb0:	615a      	str	r2, [r3, #20]


  if(huart->Instance == USART1)
 800edb2:	687b      	ldr	r3, [r7, #4]
 800edb4:	681b      	ldr	r3, [r3, #0]
 800edb6:	4a2c      	ldr	r2, [pc, #176]	@ (800ee68 <UART_SetConfig+0x114>)
 800edb8:	4293      	cmp	r3, r2
 800edba:	d103      	bne.n	800edc4 <UART_SetConfig+0x70>
  {
    pclk = HAL_RCC_GetPCLK2Freq();
 800edbc:	f7ff fe48 	bl	800ea50 <HAL_RCC_GetPCLK2Freq>
 800edc0:	60f8      	str	r0, [r7, #12]
 800edc2:	e002      	b.n	800edca <UART_SetConfig+0x76>
  }
  else
  {
    pclk = HAL_RCC_GetPCLK1Freq();
 800edc4:	f7ff fe30 	bl	800ea28 <HAL_RCC_GetPCLK1Freq>
 800edc8:	60f8      	str	r0, [r7, #12]
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
#else
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 800edca:	68fa      	ldr	r2, [r7, #12]
 800edcc:	4613      	mov	r3, r2
 800edce:	009b      	lsls	r3, r3, #2
 800edd0:	4413      	add	r3, r2
 800edd2:	009a      	lsls	r2, r3, #2
 800edd4:	441a      	add	r2, r3
 800edd6:	687b      	ldr	r3, [r7, #4]
 800edd8:	685b      	ldr	r3, [r3, #4]
 800edda:	009b      	lsls	r3, r3, #2
 800eddc:	fbb2 f3f3 	udiv	r3, r2, r3
 800ede0:	4a22      	ldr	r2, [pc, #136]	@ (800ee6c <UART_SetConfig+0x118>)
 800ede2:	fba2 2303 	umull	r2, r3, r2, r3
 800ede6:	095b      	lsrs	r3, r3, #5
 800ede8:	0119      	lsls	r1, r3, #4
 800edea:	68fa      	ldr	r2, [r7, #12]
 800edec:	4613      	mov	r3, r2
 800edee:	009b      	lsls	r3, r3, #2
 800edf0:	4413      	add	r3, r2
 800edf2:	009a      	lsls	r2, r3, #2
 800edf4:	441a      	add	r2, r3
 800edf6:	687b      	ldr	r3, [r7, #4]
 800edf8:	685b      	ldr	r3, [r3, #4]
 800edfa:	009b      	lsls	r3, r3, #2
 800edfc:	fbb2 f2f3 	udiv	r2, r2, r3
 800ee00:	4b1a      	ldr	r3, [pc, #104]	@ (800ee6c <UART_SetConfig+0x118>)
 800ee02:	fba3 0302 	umull	r0, r3, r3, r2
 800ee06:	095b      	lsrs	r3, r3, #5
 800ee08:	2064      	movs	r0, #100	@ 0x64
 800ee0a:	fb00 f303 	mul.w	r3, r0, r3
 800ee0e:	1ad3      	subs	r3, r2, r3
 800ee10:	011b      	lsls	r3, r3, #4
 800ee12:	3332      	adds	r3, #50	@ 0x32
 800ee14:	4a15      	ldr	r2, [pc, #84]	@ (800ee6c <UART_SetConfig+0x118>)
 800ee16:	fba2 2303 	umull	r2, r3, r2, r3
 800ee1a:	095b      	lsrs	r3, r3, #5
 800ee1c:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800ee20:	4419      	add	r1, r3
 800ee22:	68fa      	ldr	r2, [r7, #12]
 800ee24:	4613      	mov	r3, r2
 800ee26:	009b      	lsls	r3, r3, #2
 800ee28:	4413      	add	r3, r2
 800ee2a:	009a      	lsls	r2, r3, #2
 800ee2c:	441a      	add	r2, r3
 800ee2e:	687b      	ldr	r3, [r7, #4]
 800ee30:	685b      	ldr	r3, [r3, #4]
 800ee32:	009b      	lsls	r3, r3, #2
 800ee34:	fbb2 f2f3 	udiv	r2, r2, r3
 800ee38:	4b0c      	ldr	r3, [pc, #48]	@ (800ee6c <UART_SetConfig+0x118>)
 800ee3a:	fba3 0302 	umull	r0, r3, r3, r2
 800ee3e:	095b      	lsrs	r3, r3, #5
 800ee40:	2064      	movs	r0, #100	@ 0x64
 800ee42:	fb00 f303 	mul.w	r3, r0, r3
 800ee46:	1ad3      	subs	r3, r2, r3
 800ee48:	011b      	lsls	r3, r3, #4
 800ee4a:	3332      	adds	r3, #50	@ 0x32
 800ee4c:	4a07      	ldr	r2, [pc, #28]	@ (800ee6c <UART_SetConfig+0x118>)
 800ee4e:	fba2 2303 	umull	r2, r3, r2, r3
 800ee52:	095b      	lsrs	r3, r3, #5
 800ee54:	f003 020f 	and.w	r2, r3, #15
 800ee58:	687b      	ldr	r3, [r7, #4]
 800ee5a:	681b      	ldr	r3, [r3, #0]
 800ee5c:	440a      	add	r2, r1
 800ee5e:	609a      	str	r2, [r3, #8]
#endif /* USART_CR1_OVER8 */
}
 800ee60:	bf00      	nop
 800ee62:	3710      	adds	r7, #16
 800ee64:	46bd      	mov	sp, r7
 800ee66:	bd80      	pop	{r7, pc}
 800ee68:	40013800 	.word	0x40013800
 800ee6c:	51eb851f 	.word	0x51eb851f

0800ee70 <memset>:
 800ee70:	4603      	mov	r3, r0
 800ee72:	4402      	add	r2, r0
 800ee74:	4293      	cmp	r3, r2
 800ee76:	d100      	bne.n	800ee7a <memset+0xa>
 800ee78:	4770      	bx	lr
 800ee7a:	f803 1b01 	strb.w	r1, [r3], #1
 800ee7e:	e7f9      	b.n	800ee74 <memset+0x4>

0800ee80 <__libc_init_array>:
 800ee80:	b570      	push	{r4, r5, r6, lr}
 800ee82:	2600      	movs	r6, #0
 800ee84:	4d0c      	ldr	r5, [pc, #48]	@ (800eeb8 <__libc_init_array+0x38>)
 800ee86:	4c0d      	ldr	r4, [pc, #52]	@ (800eebc <__libc_init_array+0x3c>)
 800ee88:	1b64      	subs	r4, r4, r5
 800ee8a:	10a4      	asrs	r4, r4, #2
 800ee8c:	42a6      	cmp	r6, r4
 800ee8e:	d109      	bne.n	800eea4 <__libc_init_array+0x24>
 800ee90:	f000 f81a 	bl	800eec8 <_init>
 800ee94:	2600      	movs	r6, #0
 800ee96:	4d0a      	ldr	r5, [pc, #40]	@ (800eec0 <__libc_init_array+0x40>)
 800ee98:	4c0a      	ldr	r4, [pc, #40]	@ (800eec4 <__libc_init_array+0x44>)
 800ee9a:	1b64      	subs	r4, r4, r5
 800ee9c:	10a4      	asrs	r4, r4, #2
 800ee9e:	42a6      	cmp	r6, r4
 800eea0:	d105      	bne.n	800eeae <__libc_init_array+0x2e>
 800eea2:	bd70      	pop	{r4, r5, r6, pc}
 800eea4:	f855 3b04 	ldr.w	r3, [r5], #4
 800eea8:	4798      	blx	r3
 800eeaa:	3601      	adds	r6, #1
 800eeac:	e7ee      	b.n	800ee8c <__libc_init_array+0xc>
 800eeae:	f855 3b04 	ldr.w	r3, [r5], #4
 800eeb2:	4798      	blx	r3
 800eeb4:	3601      	adds	r6, #1
 800eeb6:	e7f2      	b.n	800ee9e <__libc_init_array+0x1e>
 800eeb8:	0800ef0c 	.word	0x0800ef0c
 800eebc:	0800ef0c 	.word	0x0800ef0c
 800eec0:	0800ef0c 	.word	0x0800ef0c
 800eec4:	0800ef10 	.word	0x0800ef10

0800eec8 <_init>:
 800eec8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800eeca:	bf00      	nop
 800eecc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800eece:	bc08      	pop	{r3}
 800eed0:	469e      	mov	lr, r3
 800eed2:	4770      	bx	lr

0800eed4 <_fini>:
 800eed4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800eed6:	bf00      	nop
 800eed8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800eeda:	bc08      	pop	{r3}
 800eedc:	469e      	mov	lr, r3
 800eede:	4770      	bx	lr
